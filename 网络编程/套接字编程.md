# TCP套接字编程

## 1、套接字地址结构

大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。每个协议族都有自己的套接字地址结构。

### 1.1、IPv4套接字地址结构

定义在`<netinet/in.h>`头文件中

    struct in_addr{
        in_addr_t s_addr;       //32位IPv4地址，网络字节序
    };

    struct sockaddr_in{
        uint8_t         sin_len;        //结构体长度-16
        sa_family_t     sin_family;     //AF_INET
        in_port_t       sin_port;       //16bit TCP/UDP的端口号，网络字节序
        struct in_addr  sin_addr;       //32位IPv4地址，网络字节序
        char            sin_zero[8];    //unused
    };

在POSIX规范中，只需要`sin_family`，`sin_port`，`sin_addr`3个字段。

在POSIX规范中，`in_addr`一般为`uint32_t`，即无符号的32位整数，`in_port_t`一般为`uint16_t`，即无符号的16位整数。这些都定义在`<sys/types.h>`中。

### 1.2、通用套接字地址结构

定义在`<sys/socket.h>`头文件中

    struct sockaddr{
        uint8_t         sa_len; 
        sa_family       sa_family;          //address family:AF_xxx
        char            sa_data[14];        //protocol-specific address
    };

这个地址结构主要用于一些套接字函数在调用时，将指向于特定协议的套接字地址结构的指针进行强制类型转换，编程指向某个通用套接字地址结构的指针。

    struct sockaddr_in serv;        //IPv4 socket address 结构体

    bind(sockfd, (struct sockaddr *) &serv, sizeof(serv));

### 1.3、IPv6套接字地址结构

结构体定义在`<netinet/in.h>`头文件中

    struct in6_addr{
        uint8_t s6_addr[16];            //128bit IPv6 address
    };

    #define SIN6_LEN                    //如果系统支持长度字段，那么SIN6_LEN必须定义

    struct sockaddr_in6{
        uint8_t         sin6_len;       //结构体长度-28字节
        sa_family_t     sin6_family;    //AF_INET6
        in_port_t       sin6_port;      //端口，网络字节序
        uint32_t        sin6_flowinfo;  //flow information，未定义
        struct in6_addr sin6_addr;      //IPv6地址，网络字节序
        uint32_t        sin6_scope_id;  //set of interfaces for a scope
    };

### 1.4、新的通用的套接字地址结构

新的`struct sockaddr_storage`足以容纳系统支持的任何套接字地址结构。定义在`<netinet/in.h>`头文件中定义的。

    struct sockaddr_storage{
        uint8_t         ss_len;
        sa_famlliy      ss_family;      
    };

`sockaddr_storage`类型提供的通用套接字结构体相比于`sockaddr`存在以下两点差别。
1. `sockaddr_storage`能够满足最苛刻的对齐要求
2. `sockaddr_storage`足够大，能够容纳系统支持的任何套接字地址结构。

### 1.5、不同套接字地址结构的比较

[参考链接](https://www.cnblogs.com/wuyepeng/p/9727242.html)

![不同套接字地址结构的比较](https://img2018.cnblogs.com/blog/1169746/201809/1169746-20180930105834429-1999825782.png)

## 2、值-结果参数

从进程到内核传递套接字地址结构的函数有：`bind()`，`connect()`，`sendto()`，这些函数的一个参数是指向某个套接字地址结构的指针，另一个参数是该结构的整数大小。
套接字地址结构的大小的数据类型实际上是`socketlen_t`，不是`int`，但是POSIX规范建议将`socketlen_t`定义为`uint32_t`

    struct sockaddr_in serv;

    connect(socketfd, (SA*)&serv, sizeof(serv));

[参考链接](https://blog.csdn.net/baidu_41388533/article/details/108196980)

![从进程到内核传递套接字地址结构](https://img-blog.csdnimg.cn/20200824142511867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzQxMzg4NTMz,size_16,color_FFFFFF,t_70)

从内核到进程传递套接字地址结构的函数有4个：`accept()`，`recvfrom()`，`getsockname()`，`getpeername()`。这四个函数的其中两个参数是指向某个套接字地址结构的指针和指向表示该结构大小的整数变量的指针。

    struct sockaddr_un cli;
    socklen_t len;

    len = sizeof(cli);
    getpeername(unixfd, (SA*)&cli, &len);

![从内核到进程传递套接字地址结构](https://img-blog.csdnimg.cn/20200824143139318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzQxMzg4NTMz,size_16,color_FFFFFF,t_70)

当函数调用时，结构大小为一个值，告诉内核结构的大小，这样内核在写结构体的时候不会越界，当函数返回时，结构大小是一个结果，告诉进程内核在该结构中存储了多少信息。

## 3、字节排序函数

小端字节序：低序字节存储在起始地址；
大端字节序：高序字节存储在起始地址；

两种字节序都有系统在使用，将某个给定系统所用的字节序称为主机字节序。

网际协议使用大端字节序来传送这些多字节整数。

主机字节序和网络字节序转换的函数

    #include <netinet/in.h>

    uint16_t htons(uint16_t host16bitvalue);
    uint32_t htonl(uint32_t host32bitvalue);            //均返回网络字节序的值
    uint16_t ntohs(uint16_t net16bitvalue);             
    uint32_t ntohl(uint32_t net32bitvalue);             //均返回主机字节序的值

 `h`代表`host`，`n`代表`net`，`s`代表`short`，`l`代表`long`，`s`视作一个16位的值，`l`视作一个32位的值。   

## 4、字节操纵函数

操作多字节字段的函数有两组，既不对数据做解释，也不假设数据是以空字符串结束的C字符串。

名字以`b`（字节）开头的为第一组函数，名字以`mem`（内存）开头的为第二组函数。

    #include <strings.h>

    void bzero(void *dest, size_t nbytes);
    void bcopy(const void *src, void *dest, size_t nbytes);
    int bcmp(const void *ptr1, const void *ptr2, size_t nbytes);    //相等返回0，否则非0

`bzero()`把目标字符串中的指定数目的字节置为0。经常使用该函数将一个套接字地址结构初始化为0。`bcopy()`将指定数目的目的字节从源字节串移到目标字节串。`bcmp()`比较任意的两个字节串。


    #include <string.h>

    void *memset(void *dest, int c, size_t len);
    void *memcpy(void *dest, const void *src, size_t nbytes);
    int memcmp(const void *ptr1, const void *ptr2, size_t nbytes);

`memset()`将目标字节串指定数目的字节置为c。`memcpy()`类似于`bcopy()`，不过两个指针的顺序是相反的。当源字节串和目标字节串重叠时，`bcopy()`可以正确处理，但是`memecpy()`的操作结果却不可知。这种情形下，需要使用`ANSI C`的`memmove()`函数。`memcmp()`比较任意两个字节串，若相同返回0，否则返回一个非0值，如果`ptr1`所指向字节串的这个字节大于`ptr2`所指字节串的字节，那么大于0，否则小于0。

## 5、inet_aton、inet_addr和inet_ntoa函数

    #include <arpa/inet.h>

    int inet_aton(const char *strptr, struct in_addr *addrptr);

    in_addr_t inet_addr(const char* strptr);

    char *inet_ntoa(struct in_addr inaddr);


`inet_aton`将`strptr`所指的C字符串转换成一个32位的网络字节序二进制IPv4地址值，并通过指针`addrptr`来存储。若成功返回1，否则返回0。

`inet_addr`进行相同的转换，返回值为32位的网络字节序二进制值。当出错时该函数返回`INADDR_NONE`常值。意味着点分十进制数串不能由该函数处理。这个函数已经被废弃。

`inet_ntoa`将一个32为的网络字节序二进制IPv4地址转换成相应的点分十进制数串，由于该函数的返回值所指向的字符串在静态内存，意味着该函数是不可重入的。


## 6、inet_pton、inet_ntop函数

这两个函数是随着IPv6出现的新函数，对于IPv4和IPv6地址都适用。

    #include <arpa/inet.h>

    int inet_pton(int family, const char *strptr, void *addrptr);

    const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len);

这两个函数的`family`的参数即可以是`AF_INET`，也可以是`AF_INET6`。如果以不被支持的地址族作为`family`参数，这两个函数就返回一个错误，并将errno置成`EAFNOSUPOORT`。

`inet_pton`将`strptr`所指向的字符串转换，并通过`addrptr`指针存放二进制结果。成功返回1，如果对于指定的`family`而言输入的字符串不是有效的表达格式，那么返回值为0。

`inet_ntop`进行相反的转换，从数值格式`addrptr`转换到表达格式`strptr`。`len`参数是目标存储单元的大小。为了有助于指定这个大小，在`<netinet/in.h>`头文件中定义

    #define INET_ADDRSTRLRN     16      //for IPv4 dotted-decimal
    #define INET6_ADDRSTRLRN    46      //for IPv6 hex string

如果`len`太小，不足以容纳表达格式结果（包括结尾的空字符），那么返回一个空指针，并置为`errno`为`ENOSPC`。`strptr`参数不可以是一个空指针。

## 7、sock_ntop和相关函数




## 8、readn、writen、readline函数

字节流套接字（如TCP套接字）上的`read`和`write`函数所表现的行为不同于通常的文件I/O。字节流套接字上调用`read`或者`write`函数输入或者输出的字节数可能比请求的数量少，这不是出错。这个现象的原因在于内核中用于套接字的缓冲区可能已经到达了极限。此时需要调用者再次调用`read`或者`write`函数，以输入或者输出剩余的字节。

> 字节流套接字也被称为TCP套接字，是一种面向连接的套接字类型。使用的是字节流，对于包的长度没有限制。


为了预防万一，不让实现返回一个不足的字节计数值。下面三个函数是读写字节流套接字时总需要使用的函数。

    #include "unp.h"

    ssize_t readn(int filedes, void *buff, size_t nbytes);

    ssize_t writen(int filedes, void *buff, size_t nbytes);

    ssize_t readline(int filedes, void *buff, size_t maxlen);


    #include "unp.h"

    //readn函数，往一个描述符读n字节
    ssize_t readn(int fd, void *vptr, size_t n)
    {
        size_t nleft;
        ssize_t nread;
        char *ptr;

        ptr = vptr;
        nleft = n;
        while(n>0)
        {
            if((nread = read(fd, ptr, nleft))<0)
            {
                if(errno == EINTR)
                    nread = 0;          //call read again
                else 
                    return -1;
            }
            else if(nread == 0)
            {
                break;                  //EOF
            }
            nleft -= nread;
            ptr += nread;
        }
        return (n-nleft);               //return >=0
    }

    //writen函数，往一个描述符写n字节
    ssize_t writen(int fd, const void *vptr, size_t n)
    {
        size_t nleft;
        ssize_t nwritten;
        const char *ptr;

        ptr = vptr;
        nleft = n;
        while(nleft > 0)
        {
            if((nwritten = write(fd, ptr, nleft)) <= 0)
            {
                if(nwritten < 0 && errno == EINTR)
                    nwritten = 0;           //call write() again
                else 
                    return -1;
            }
            nleft -= nwritten;
            ptr += nwritten;
        }
        return n;
    }

    

