# 队列

> 队列：队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是一种先进先出的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。

比如用键盘进行输入，到显示器上如笔记本软件的输出，其实就是队列的典型应用。

## 队列的抽象数据类型

    ADT 队列
    Data
        同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系。
    Operation
        InitQueue(*Q):初始化操作，建立一个空队列
        DestoryQueue(*Q):若队列Q存在，则销毁它
        ClearQueue(*Q):将队列Q清空
        QueueEmpty(Q):若队列Q为空，返回true，否则返回false
        GetHead(Q, *e):若队列Q存在且非空，用e返回队列Q的队头元素
        EnQueue(*Q, e):若队列Q存在，插入新元素e到队列Q中并称为队尾元素
        DeQueue(*Q, *e):删除队列Q中的队头元素，并用e返回其值。
        QueueLength(Q):返回队列Q的元素个数
    endADT

## 循环队列

### 队列线性存储的不足

普通的线性队列在插入和删除的时候和线性表的顺序存储结构是一样的。插入的时候在队尾插入，时间复杂度为O(1)，删除的时候从队头删除，时间复杂度为O(n)。

为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，`front`指针指向队头元素，`rear`指针指向队尾元素下一个位置，这样当`front`等于`rear`时，此队列不是还剩一个元素，而是空队列。

还存在一个问题，就是假设数组队列总个数不超过5个，但是数组末尾的元素已经被占用，再向后加就会产生数组越界的错误，但是实际上队列在下标为0和1的位置还是空闲的，这种现象就叫做假溢出。

### 循环队列的定义

> 解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。将队列的这种头尾相接的顺序存储结构叫做称为循环队列。

循环队列的`rear`指针可以改为指向下标为0的位置。这样就不会造成指针指向不明的问题了。如下

![](https://images2018.cnblogs.com/blog/1407330/201806/1407330-20180606090235525-540614245.png)

- 接着$a_6$入队，就将它放在下标为0处，`rear`指针指向下标为1处。
- 接着$a_7$入队，`rear`和`front`指针重合，同时指向下标为2的位置。
  
前面说过空队列时，`front`等于`rear`，现在队列满了，`front`也等于`rear`，需要如何区分
1. 使用一个标志变量`flag`，当`flag=0`时，队列为空，`flag=1`时，队列满了。
2. 修改队列满的条件，当队列满时，数组还有一个空闲单元，此时就认为队列已经满了，就是不允许上面的$a_7$插入队列。

讨论第二种方法，`rear`可能比`front`大，也有可能比`front`小，若队列的最大尺寸为QueueSize，那么队列满的条件就是:

$$(rear+1)\%QueueSize=front$$

当`rear>front`时，此时队列的长度为`rear-front`；当`rear<front`时，队列的长度分为两段，一段是`QueueSize-front`，另一段是`0+rear`，总长度为`rear-front+QueueSize`

因此通用的计算队列长度的公式为：

$$(rear-front+QueueSize)\%QueueSize$$


    //循环队列顺序存储结构代码
    typedef int QElemType;

    typedef struct 
    {
        QElemType data[MAXSIZE];        
        int front;
        int rear;
    }SqQueue;

    //初始化一个空队列
    Status InitQueue(SqQueue *Q)
    {
        Q->front = 0;
        Q->rear = 0;
        return OK;
    }

    //返回Q的元素个数，也就是队列的当前长度
    int QueueLength(SqQueue Q)
    {
        return (Q.rear-Q.front+MAXSIZE)%MAXSIZE
    }

    //若队列未满，则插入元素e为Q新的队尾元素
    Status EnQueue(SqQueue *Q, QElemType e)
    {
        if((Q->rear+1)%MAXSIZE == Q->front)         //队列是否满
        {
            return ERROR;
        }
        Q->data[Q->rear] = e;                       //将元素e赋值给队尾
        Q->rear = (Q->rear+1)%MAXSIZE;              //rear指针向后移一位
                                                    //到最后则转到数组头部
        return OK;
    }

    //若队列不为空，则删除Q中队头元素，用e返回其值
    Status DeQueue(SqQueue *Q, QElemType *e)
    {
        if(Q->front == Q->rear)                     //队列是否空
        {
            return ERROR;
        }

        *e = Q->data[Q->front];                     //将队头元素赋值给e
        Q->front = (Q->front+1)%MAXSIZE;            //front指针向后移一位置
                                                    //若到最后则转到数组头部
        return OK;
    }

顺序存储，如果不是循环队列，算法的时间性能不高，但是循环队列又面临着数组会溢出的问题。


## 队列的链式存储结构及实现

> 队列的链式存储结构：其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列。
>

将队头指针指向链队列的头结点，而队尾指针指向终端结点。

空队列时，`front`和`rear`都指向头结点

    //链队列的结构
    typedef int QElemType;

    typedef struct QNode
    {
        QElemType data;
        struct QNode *next;
    }QNode,*QueuePtr;

    typedef struct                      //队列的链表结构
    {
        QueuePtr front,rear;            //队头、队尾指针
    }LinkQueue;

## 队列的链式存储结构——入队操作

入队列就是在链表尾部插入结点

    //插入元素e为Q的新的队尾元素
    Status EnQueue(LinkQueue *Q, QElemType e)
    {
        QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
        if(!s)
        {
            exit(OVERFLOW);
        }
        s->data = e;
        s->next = NULL;
        Q->rear->next = s;          //把元素e的新结点s赋值给原队尾结点的后继
        Q->rear = s;                //把当前的s设置成队尾结点，rear指向s
        return OK;
    }


## 队列的链式存储结构——出队操作

出队列就是头结点的后继节点出队，将头结点的后继改成它后面的结点，若链表除了头结点之外只剩一个元素，则需要将`rear`指向头结点

    //若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR
    Status DeQueue(LinkQueue *Q, QElemType *e)
    {
        QueuePtr p;
        if(Q->front == Q->rear)
        {
            return ERROR;
        }
        p = Q->front->next;                 //将欲删除的队头结点暂存给p
        *e = p->data;                       //将欲删除的队头结点的值赋给e
        Q->front->next = p->next;           //将原队头结点的后继p->next赋值个肌肉节点后继
        if(Q->rear == p)                    //若队头就是队尾，则删除后将rear指向头结点
        {
            Q->rear = Q->front;
        }
        free(p);
        return OK;
    }

在确定队列长度最大值的情况下，建议使用循环队列，如果无法预估队列的长度，则使用链队列。


栈和队列都是特殊的线性表，只不过对于插入和删除操作做了限制。