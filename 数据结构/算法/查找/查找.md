# 查找概论

查找表是由同一类型的数据元素构成的集合。关键字是数据元素中某个数据项的值，称为键值。若关键字可以唯一地标志一个记录，则称此关键字为主关键字。对于那些可以识别多个数据元素或者记录的关键字，称为次关键字。


> 查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或者记录。

查找表按照操作方式来分有两大种，静态查找表和动态查找表。
- 静态查找表：只作查找操作的查找表，主要操作有
  - 查找某个特定数据元素是否在查找表中
  - 检索某个特定数据元素的各种属性
- 动态查找表：在查找的过程中插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。
  - 查找时插入数据元素
  - 查找时删除数据元素

为了方便查找，要设置一个面向查找操作的数据结构，称为查找结构。


## 顺序表查找

对线性表进行查找操作，就是静态查找表

顺序查找也叫做线性查找，是最基本的查找。查找过程是：

从表中的第一个或者最后一个记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相同，则查找成功，找到所查的记录；如果知道最后一个或者第一个记录，其关键字和给定值比较都不相等时，则表中没有所查的记录，查找不成功。

### 顺序表查找算法

    //顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字
    int Sequential_Search(int *a, int n, int key)
    {
        int i;
        for(i=1;i<=n;i++)
        {
            if(a[i]==key)
            {
                return i;
            }
        }
        return 0;
    }

### 顺序表查找优化

设置一个哨兵，解决不需要每次让i与n作比较

    //有哨兵顺序查找

    int Sequential_Search2(int *a, int n, int key)
    {
        int i;
        a[0] = key;             //设置a[0]为关键字值，称为哨兵
        i = n;                  //循环从数组尾部开始
        while(a[i]!=key)        
        {
            i--;
        }
        return i;               //返回0则说明查找失败
    }


顺序查找当n很大时，查找效率很低下，优点就是算法简单。


## 有序表查找

### 折半查找

> 折半查找：又称为二分查找。它的前提是线性表中的记录必须是关键有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的右半区继续查找，不断重复上述过程，z直到查找成功，或所有查找区域无记录，查找失败为止。

    int Binary_Search(int *a, int n, int key)
    {
        int low,high,mid;
        low = 1;                //定义最低下标为记录首位
        high = n;               //定义最高下标为记录末位
        while(low<=high)
        {
            mid = (low+high)/2; //折半
            if(key<a[mid])
            {
                high=mid-1;     //最高下标调整到中位下标小一位
            }
            else if(key>a[mid]) 
            {
                low=mid+1;      //最低下标调整到中位下标大一位
            }
            else
            {
                return mid;     //若相等则说明mid即为查找到的位置
            }
        }
        return 0;
    }


### 插值查找

> 插值查找：是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式$(key-a[low])/(a[high]-a[low])$


    //插值查找
    int Interpolation_Search(int *a, int n, int key)
    {
        int low,high,mid;
        low = 1;
        high = n;
        while(low<=high)
        {
            mid=low+(high-low)*(key-a[low])/(a[high]-a[low]);   //插值
            if(key < a[mid])                                    //若查找值比插值小
            {
                high = mid -1;
            }
            else if(key > a[mid])
            {
                low = mid+1;
            }
            else
            {
                return mid;
            }
        }
        return 0;
    }


### 斐波那契查找


    int Fibonacci_Search(int *a, int n, int key)        /*斐波那契查找*/
    {
        int low,high,mid,i,k;
        low = 1;                            //定义最低下标为记录首位
        high = n;                           //定义最高下标为记录末位
        k = 0;                              
        while(n>F[k]-1)                     //计算n位斐波那契数列的位置
        {
            k++;
        }
        for(i = n; i<F[k]-1; i++)           //将不满的数值补全
        {
            a[i] = a[n];
        }
        while(low<=high)
        {
            mid = low + F[k-1]-1;           //计算当前的分隔的下标
            if(key<a[mid])                  //若查找记录小于当前分隔记录
            {
                high=mid-1;                 //最高下标调整到分隔下标mid处
                k=k-1;                      //斐波那契数列下标减一位
            }
            else if(key>a[mid])             //若查找记录大于当前分隔记录
            {
                low=mid+1;                  //最低下标调整到分隔下标mid+1处
                k=k-1;                      //斐波那契数列下标减两位
            }
            else 
            {
                if(mid <= n)                //若相等则说明mid即为查找到的位置
                {       
                    return mid;             
                }
                else 
                {
                    return n;               //若mid>n说明是补全数值，返回n
                }
            }
        }
        return 0;
    }


## 线性索引查找

## 二叉排序树


> 二叉排序树：又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树

1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
2. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
3. 它的左右子树，也分别为二叉排序树

构造一棵二叉排序树的目的，其实不是为了排序，而是为了提高查找和插入删除关键字的速度。在一个有序数据集上的查找，速度总是要快于无序的数据集。


### 二叉排序树的查找操作

    //二叉树的二叉链表的结点结构定义
    typedef struct BiNode                           //结点结构
    {
        int data;                                   //结点数据
        struct BiTNode *lchild, *rchild;            //左右孩子指针
    }

    Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)
    {
        //递归查找二叉排序树T中是否存在key
        if(!T)                      //若查找不成功，指针p指向查找路径上访问的最后一个结点并返回FALSE
        {
            *p = f;
            return FALSE;
        }
        else if(key ==T->data)          //若查找成功，则指针p指向该数据元素结点，并返回TRUE
        {
            *p = T;
            return TRUE;
        }
        else if(key<T->data)
        {
            return SearchBST(T->lchild, key, T, p);         //在左子树中继续查找
        }
        else 
        {
            return SearchBST(T->rchild, key, T, p);         //在右子树中继续查找
        }
    }

### 二叉排序树的插入操作

    Status InsertBST(BiTree *T, int key)
    {
        BiTree p, s;
        if(!SearchBST(*T, key, NULL, &p))           //查找不成功
        {
            s = (BiTree)malloc(sizeof(BiTNode));
            s->data = key;
            s->lchild = s->rchild = NULL;
            if(!p)
            {
                *T = s;                             //插入s为新的根结点
            }
            else if(key < p->data)
            {
                p->lchild = s;                      //插入s为左孩子
            }
            else
            {
                p->rchild = s;                      //插入s为右孩子
            }
            return TRUE;
        }
        else 
        {
            return FALSE;                           //树中已经有与关键字相同的结点，不再插入
        }
    }

### 二叉排序树的删除操作

对于删除结点有三种情况：
1. 叶子结点
2. 仅有左或者右子树的结点
3. 左右子树都有的结点

代码详情

    Status DeleteBST(BiTree *T, int key)
    {
        //二叉排序树T中存在关键字等于key的数据元素时，则删除该数据结点
        if(!*T)                         //不存在关键字等于key的数据元素
        {
            return FALSE;
        }
        else
        {
            if(key == (*T)->data)       //查找到关键字等于key的数据元素
            {
                return Delete(T);
            }
            else if(key<(*T)->data)
            {
                return DeleteBST(&(*T)->lchild, key);
            }
            else 
            {
                return DeleteBST(&(*T)->rchild, key);
            }
        }
    }


    Status Delete(BiTree *p)
    {
        //从二叉排序树中删除结点p，并重接它的左或者右子树
        BiTree q,s;
        if((*p)->rchild == NULL)            //右子树空则只需要重接它的左子树（待删结点是叶子也走此分支）
        {
            q=*p;
            *p=(*p)->lchild;
            free(q);
        }
        else if((*p)->lchild == NULL)       //只需重接它的右子树
        {
            q=*p;
            *p=(*p)->rchild;
            free(q);
        }
        else
        {
            q=*p;
            s=(*p)->lchild;
            while(s->rchild)                //转左，然后向右到尽头（找到待删结点的前驱）
            {
                q=s;
                s=s->rchild;
            }
            (*p)->data=s->data;             //s指向被删结点直接前驱（用被删结点前驱的值取代被删结点）
            if(q!=*p)
            {
                q->rchild = s->lchild;      //重接q的右子树
            }
            else
            {
                q->lchild = s->lchild;      //重接q的左子树
            }
            free(s);
        }
        return TRUE;

    }

## 平衡二叉树（AVL树）




## 多路查找树（B树）

## 散列表查找（哈希表）