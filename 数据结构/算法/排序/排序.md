# 排序

排序的稳定性：假设$k_i=k_j(1<=i<=n,1<=j<=n,i!=j)$，且在排序之前的序列$r_i$领先于$r_j$。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之则称所用的排序方法是不稳定的。


|排序分类|说明|
|-|-|
|内排序|在排序整个过程中，待排序的所有记录全部都被放置在内存中。<li>插入排序；<li>交换排序；<li>选择排序；<li>归并排序|
|外排序|由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才行|



## 排序用到的结构和函数

    #define MAXSIZE 10000       //用于要排序数组个数的最大值，可以根据需要修改
    typedef struct 
    {
        int r[MAXSIZE+1];       //用于存储要排序数组，r[0]用作哨兵或临时变量
        int length;             //用于记录顺序表的长度
    }SqList;

    //交换L中的数组r的下标为i和j的值
    void swap(SqList *L, int i, int j)
    {
        int temp = L->r[i];
        L->r[i] = L->r[j];
        L->r[j] = temp;
    }

## 冒泡排序

> 冒泡排序：是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。

    //对顺序表L做交换排序
    void BubbleSort0(SqList *L)
    {
        int i,j;
        for(i=1;i<L->length;i++)
        {
            for(j=i+1;j<=L->length;j++)
            {
                if(L->r[i]>L->r[j])
                {
                    swap(L,i,j);        //交换L->r[i]与L->r[j]的值
                }
            }
        }
    }

    //标准冒泡排序算法
    void BubbleSort(SqList *L)
    {
        int i,j;
        for(i=1;i<L->length;i++)
        {
            for(j=L->length-1;j>=i;j--)     //注意j是从后往前循环
            {
                if(L->r[j]>L->r[j+1])       //若前者大于后者
                {
                    swap(L,j,j+1);          //交换L->r[j]与L->r[j+1]的值
                }
            }
        }
    }

    //优化冒泡排序算法-避免有序的情况下进行无意义的循环
    void BubbleSort2(SqList *L)
    {
        int i,j;
        Status flag = TRUE;                         //用flag作为标记
        for(i=1; i<L->length&&flag;i++)             //若flag为TRUE则表示有数据交换，否则退出循环
        {
            flag = FALSE;                           //初始为FLASE
            for(j=L->length-1;j>=i;j--)
            {
                if(L->r[j]>L->r[j+1])
                {
                    swap(L,j,j+1);                  //交换L->r[j]与L->r[j+1]的值
                    flag = TRUE;                    //如果有数据交换，则flag为TRUE
                }
            }
        }
    }

冒泡排序的时间复杂度为$O(n^2)$

## 简单选择排序算法

> 简单选择排序的就是通过n-i次关键字之间的比较，从n-i+1个记录中选择出关键字最小的记录，并和第i(1<=i<=n)个记录比较。


    //对顺序表L做简单选择排序
    void SelectSort(SqList *L)
    {
        int i,j,min;
        for(i=1;i<L->length;i++)
        {
            min = i;                        //将当前下标定义为最小值下标
            for(j=i+1;j<=L->length;j++)     //循环之后的数据
            {
                if(L->r[min]>L->r[j])       //如果有小于当前最小值的关键字
                {
                    min = j;                //将此关键字的下标赋值给min
                }
            }
            if(i!=min)                      //若min不等于i，说明找到最小值，交换
            {
                swap(L,i,min);              //交换L->r[i]和L->r[min]的值
            }
        }
    }

简单选择排序的时间复杂度为$O(n^2)$


## 直接插入排序

> 直接插入排序：将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增加1的有序表。

    //对顺序表L做直接插入排序
    void InsertSort(SqList *L)
    {
        int i,j;
        for(i=2;i<=L->length;i++)
        {
            if(L->r[i]<L->r[i-1])               //需要将L->r[i]插入有序子表
            {
                L->r[0] = L->r[i];              //设置哨兵
                for(j=i-1;L->r[j]>L->r[0];j--)
                {
                    L->r[j+1] = L->r[j];        //记录后移
                }
                L->r[j+1] = L->r[0];            //插入到正确位置
            }
        }
    }

直接插入排序法的时间复杂度为$O(n^2)$


## 希尔排序

> 希尔排序：将原先有大量记录数的记录进行分组，分成若干个子序列，对每个子序列内部进行直接插入排序，当整个序列都基本有序时，再对全体记录进行一次直接插入排序。

所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间。

采取跳跃分隔的策略：将相距某个增量的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后的到的结果是基本有序而不是局部有序。

    //对顺序表L作希尔排序
    void ShellSort(SqList *L)
    {
        int i,j,k = 0;
        int increment = L->length;              //increment为增量，初始值等于待排序的记录数
        do
        {
            increment = increment/3+1;          //增量序列
            for(i=increment+1;i<=L->length;i++)
            {
                if(L->r[i]<L->r[i-increment])
                {
                    L->r[0] = L->r[i];          //暂存在L->r[0]
                    for(j=i-increment;j>0&&L->r[0]<L->r[j];j-=increment)
                    {
                        L->r[j+increment] = L->r[j];            //记录后移
                    }
                    L->r[j+increment] = L->r[0];                //插入
                }
            }
        }
        while(increment > 1);
    }

增量序列的最后一个增量值必须等于1才行。希尔排序的时间复杂度为$O(n^(3/2))$


## 堆排序

堆是具有下列性质的完全二叉树：
每个结点的值都大于或者等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或者等于其左右孩子的值，称为小顶堆。根结点一定是堆中所有结点的最大或者最小者。


> 堆排序：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造一个堆，这样就会得到n个元素的次大值。如此反复执行，便能得到一个有序序列。

    //对顺序表L进行堆排序
    void HeapSort(SqList *L)
    {
        int i;
        for(i=L->length/2; i>0; i--)
        {
            HeapAdjust(L, i, L->length);                    //把L中的r构建成一个大顶堆
        }
        for(i=L->length; i>1; i--)
        {
            swap(L, 1, i);                                  //将堆顶记录和当前未经排序子序列最后一记录交换
            HeapAdjust(L, 1, i-1);                          //将L->r[1...i-1]重新调整为大顶堆
        }
    }

    //
    void HeapAdjust(SqList *L, int s, int m)
    {
        //本函数调整L->r[s]的关键字，使L->r[s...m]称为一个大顶堆
        int temp,j;
        temp = L->r[s];
        for(j=2*s; j<=m; j*=2)              //沿关键字较大的孩子结点向下筛选
        {
            if(j<m && L->r[j]<L->r[j+1])
            {
                ++j;                        //j为关键字中较大的记录的下标
            }
            if(temp>=L->r[j])
            {
                break;                      //rc应插在位置s上
            }
            L->r[s]=L->r[j];                
            s=j;
        }
        L->r[s] = temp;
    }

堆排序的时间复杂度为$O(nlogn)$

## 归并排序

> 归并排序：假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到|n/2|（|x|表示不小于x的最小整数）个长度为2或1的有序子序列；再两两归并，如此重复，直到得到一个长度n的有序序列为止，这种排序方法称为2路归并排序。

    //对顺序表L做归并排序
    void MergeSort(SqList *L)
    {
        MSort(L->r, L->r, 1, L->length);
    }

    void MSort(int SR[], int TR1[], int s, int t)
    {
        int m;
        int TR2[MAXSIZE+1];
        if(s==t)
        {
            TR1[s]=SR[s];
        }
        else
        {
            m=(s+t)/2;                          //将SR[s...t]平分为SR[s...m]和SR[m+1...t]
            MSort(SR, TR2, s, m);               //递归地将SR[s...m]归并为有序的TR2[s...m]
            Msort(SR, TR2, m+1, t);             //递归地将SR[m+1...t]归并为有序的TR2[m+1...t]
            Merge(TR2, TR1, s, m, t);           //将TR2[s...m]和TR2[m+1...t]归并到TR1[s...t]
        }
    }

    void Merge(int SR[], int TR[], int i, int m, int n)
    {
        //将有序的SR[i...m]和SR[m+1...n]归并为有序的TR[i...n]
        int j,k,l;
        for(j=m+1,k=i; i<=m && j<=n; k++)           //将SR中记录由小到大地并入TR
        {
            if(SR[i] < SR[j])
            {
                TR[k]=SR[i++];
            }
            else
            {
                TR[k]=SR[j++];
            }
            if(i<=m)
            {
                for(l=0;l<=m-i;l++)
                {
                    TR[k+l]=SR[i+l];                //将剩余的SR[i..m]复制到TR
                }
            }
            if(j<=n)
            {
                for(l=0;l<=n-j;l++)
                {
                    TR[k+l]=SR[j+l];                //将剩余的SR[j..n]复制到TR
                }
            }

        }
    }

归并排序的时间复杂度为$O(nlogn)$，空间复杂度$O(n+logn)$


归并排序使用了大量的递归，容易造成时间和空间上的性能损耗。将递归转换成迭代。

    //对顺序表L作归并非递归排序
    void MergeSort2(SqList *L)
    {
        int *TR = (int *)malloc(L->length * sizeof(int));       //申请额外空间
        int k=1;
        while(k<L->length)
        {
            MergePass(L->r, TR, k, L->length);
            k=2*k;                                              //子序列长度加倍
            MergePass(TR, L->r, k, L->length);
            k=2*k;                                              //子序列长度加倍
        }
    }

    void MergePass(int SR[], int TR[], int s, int n)
    {
        //将SR[]中相邻长度为s的子序列两两归并到TR[]
        int i=1;
        int j;
        while(i<=n-2*s+1)                   //两两归并
        {
            Merge(SR, TR, i, i+s-1, i+2*s-1);
            i=i+2*s;
        }
        if(i<n-s+1)                         //归并最后两个序列
        {
            Merge(SR, TR, i, i+s-1, n);
        }
        else                                //若最后只剩下单个子序列
        {
            for(j=i; j<=n; j++)
            {
                TR[j] = SR[j];
            }
        }
    }

空间复杂度为$O(n)$，使用归并排序时，尽量考虑使用非递归方法。


## 快速排序

> 快速排序的基本思想：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可以分别对这两部分记录继续进行排序，已达到整个序列有序的目的。


    //对顺序表L作快速排序
    void QuickSort(SqList *L)
    {
        QSort(L, 1, L->length);
    }

    //对顺序表L中的子序列L->r[low...high]作快速排序
    void QSort(SqList *L, int low, int high)
    {
        int pivot;
        if(low<high)
        {   
            //将L->r[low...high]一分为二，算出枢轴值pivot
            piovt = Partition(L, low, high);
            QSort(L, low, piovt-1);             //对低子表递归排序
            QSort(L, pivot+1, high);            //对高子表递归排序
        }
    }

`Partition()`函数要做的是先选取一个关键字，想办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，这样的关键字称为枢轴值。

    int Partition(SqList *L, int low, int high)
    {
        //交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置，此时在它之前（后）均不大（小）于它
        int pivotkey;

        pivotkey = L->r[low];                   //用子表的第一个记录做枢轴记录
        while(low<high)
        {
            while(low<high&&L->r[high]>=pivotkey)
            {
                high--;
            }
            swap(L, low, high);                 //将比枢轴
            while(low<high&&L->r[low]<=pivotkey)
            {
                low++;
            }
            swap(L, low, high);                 //将比枢轴记录大的记录交换到高端
        }
    }

简单快速排序的时间复杂度为$O(nlogn)$，由于关键字的比较和交换是跳跃进行的。所以快速排序是一种不稳定的排序方法。

### 优化选取枢轴

> 三数取中：取三个关键字先进行排序，将中间数作为枢轴，一般是取左端，右端和中间三个数。

在`Partition()`函数中的`int pivotkey;`和`pivotkey=L->r[low];`之间加上一段代码

    int pivotkey;

    int m = low+(high-low)/2;           //计算数组中间的元素的下标
    if(L->r[low]>L->r[high])
    {
        swap(L, low, high);             //交换左端和右端数据，保证左端较小
    }
    if(L->r[m]>L->r[high])
    {
        swap(L, high, m);               //交换中间与右端数据，保证中间较小
    }
    if(L->r[m]>L->r[low])
    {
        swap(L, m, low);                //交换中间与左端数据，保证左边较小
    }

    //此时，L->r[low]已经为整个序列左，中，右三个关键字的中间值
    pivotkey = L->r[low];               //用子表的第一个记录作枢轴记录

对于较大的待排序序列，甚至可以使用九数取中。


### 优化不必要的交换

    int Partition1(SqList *L, int low, int high)
    {
        int pivotkey;

        int m = low+(high-low)/2;           //计算数组中间的元素的下标
        if(L->r[low]>L->r[high])
        {
            swap(L, low, high);             //交换左端和右端数据，保证左端较小
        }
        if(L->r[m]>L->r[high])
        {
            swap(L, high, m);               //交换中间与右端数据，保证中间较小
        }
        if(L->r[m]>L->r[low])
        {
            swap(L, m, low);                //交换中间与左端数据，保证左边较小
        }

        //此时，L->r[low]已经为整个序列左，中，右三个关键字的中间值
        pivotkey = L->r[low];               //用子表的第一个记录作枢轴记录
        L->r[0] = pivotkey;                 //将枢轴关键字备份到L->r[0]
        while(low<high)
        {
            while(low<high&&L->r[high]>=pivotkey)
            {
                high--;
            }
            L->r[low]=L->r[high];           //采用替换而不是交换的方式进行操作
            while(low<high&&L->r[low]<=pivotkey)
            {
                low++;
            }
            L->r[high]=L->r[low];           //采用替换而不是交换额度方式进行操作
        }
        L->r[low]=L->r[0];                  //将枢轴数值替换回L->r[low]
        return low;                         //返回枢轴所在位置
    }

### 优化小数组时的排序方案

    #define MAX_LENGTH_INSERT_SORT 7    //用于快速排序时判断是否选用插入排序阈值

    //对顺序表L中的子序列L->r[low...high]作快速排序
    void QSort1(SqList *L, int low, int high)
    {
        int pivot;
        if((high-low)>MAX_LENGTH_INSERT_SORT)
        {
            pivot = Partition1(L, low, high);       //将L->r[low...high]一分为二，算出枢轴值pivot
            QSort1(L, low, pivot-1);                //对低子表递归排序
            QSort1(L, pivot+1, high);               //对高子表递归排序
        }
        else
        {
            InsertSort(L);                          //当high-low小于等于常数时用直接插入排序
        }
    }

### 优化递归操作

对`QSort()`实施尾递归优化

    //尾递归
    void QSort2(SqList *L, int low, int high)
    {
        int pivot;
        if((high-low)>MAX_LENGTH_INSERT_SORT)
        {
            while(low<high)
            {
                pivot=Partition1(L, low, high);     //将L->r[low...high]一分为二，算出枢轴值pivot
                QSort2(L, low, pivot-1);            //对低子表递归排序
                low=pivot+1;                        //尾递归
            }
        }
        else
        {
            InsertSort(L);                          //当high-low小于等于常数时用直接插入排序
        }
    }

## 排序算法比较

排序算法分类：
- 简单算法：冒泡、简单选择、直接插入
- 改进算法：希尔、堆、归并、快速


|排序方法|平均情况|最好|最差|辅助空间|稳定性|
|-|-|-|-|-|-|
|冒泡排序|$O(n^2)$|$O(n)$|$O(n^2)$|$O(1)$|稳定|
|简单选择排序|$O(n^2)$|$O(n^2)$|$O(n^2)$|$O(1)$|稳定|
|直接插入排序|$O(n^2)$|$O(n)$|$O(n^2)$|$O(1)$|稳定|
|希尔排序|$O(nlogn)-O(n^2)$|$O(n^1.3)$|$O(n^2)$|$O(1)$|不稳定|
|堆排序|$O(nlogn)$|$O(nlogn)$|$O(nlogn)$|$O(1)$|不稳定|
|归并排序|$O(nlogn)$|$O(nlogn)$|$O(nlogn)$|$O(1)$|不稳定|
|堆排序|$O(nlogn)$|$O(nlogn)$|$O(nlogn)$|$O(n)$|稳定|
|快速排序|$O(nlogn)$|$O(nlogn)$|$O(n^2)$|$O(logn)-O(n)$|不稳定|