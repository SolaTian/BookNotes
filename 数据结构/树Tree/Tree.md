# 树

## 树的定义

之前的数据结构都是一对一的线性结构，树是一种一对多的数据结构。

> 树：是n个结点的有限集。n=0时称为空树。在任意一棵非空树中：
> 1. 有且仅有一个特定的根(root)的结点；
> 2. 当n>1时，其余结点可以分为m(m>0)个互不相交的有限集$T_1$，$T_2$，...$T_m$，其中每一个集合本身又是一棵树，并且称为根的子树。

需要注意的是，n>0的根结点是唯一的，不可能存在多个根结点。m>0时，子树的个数没有限制，但它们一定是互不相交的。

### 树的结点

结点拥有的子树数称为结点的度；度为0的结点称为叶节点或者终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各个结点的度的最大值。


结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。同一个双亲的孩子之间互称兄弟。结点的祖先是从根到该结点所经分支上的所有结点。以某个结点为根的子树中的任一节点都称为该结点的孩子。

结点的层次从根开始算起，根为第一层，根的孩子为第二层。树中结点的最大层次称为树的深度或高度。

如果将树中结点的各个子树看成从左到右是有次序的，不能互换的，则称该树为有序的，否则称为无序树。

森林是m棵互不相交的树的集合。


|线性结构|树结构|
|-|-|
|<li>第一个数据元素：无前驱；<li>最后一个数据元素：无后继；<li>中间元素，一个前驱，一个后继|<li>根节点：无双亲，唯一；<li>叶节点：无孩子，可以多个；<li>中间节点：一个双亲多个孩子|

## 树的抽象数据类型

    ADT 树
    Data
        树是由一个根结点和若干棵子树构成的。树中节点具有相同数据类型及层次关系
    Operation
        InitTree(*T):构造空树T
        DestroyTree(*T):销毁树T
        CreateTree(*T, definition):按照definition中给出的树的定义来构造树
        ClearTree(*T):若树T存在，则将树T清为空树
        TreeEmpty(T):若树T为空树，返回true，否则返回false
        TreeDepth(T):返回T的深度
        Root(T):返回T的根结点
        Value(T, cur_e):cur_e是树T中的一个结点，返回此节点的值
        Assign(T, cur_e, value):给树T的结点cur_e赋值为Value
        Parent(T, cur_e):若cur_e是树T的非根结点，则返回它的双亲，否则返回空
        LeftChild(T, cur_e):若cur_e是树T的非根结点，则返回它的最左孩子，否则返回空
        RightSibling(T, cur_e):若cur_e有右兄弟，则返回它的右兄弟，否则返回空
        InsertChild(*T, *p, i, c):其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p所指结点的第i棵子树
        DeleteChild(*T, *p, i):其中p指向树T的，i为所指结点p的度，操作结果为删除T中p所指节点的第i棵子树
    endADT

## 树的存储结构

使用顺序存储结构，由于树的某个结点的孩子可以有多个，意味着，无论按照何种顺序将树中所有结点存储到数组中，结点的存储位置都无法直接反映逻辑关系。树的表示方法主要有双亲表示法、孩子表示法、孩子兄弟表示法。

### 双亲表示法

在树中，除了根结点外，其余每个结点，它不一定有孩子，但是一定有一个双亲。

假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。

|data|parent|
|-|-|

`data`是数据域，存储结点的数据信息；`parent`是指针域，存储该结点的双亲在数组中的下标。

    #define MAX_TREE_SIZE 100

    typedef int TElemType;      //树结点的数据类型，目前暂定为整型

    typedef struct PTNode       //结点结构
    {
        TElemType data;         //结点数据
        int parent;             //双亲位置
    }PTNode;

    typedef struct              //树结构
    {
        PTNode nodes[MAX_TREE_SIZE];        //结点数组
        int r,n;                            //根的位置和结点数
    }PTree;

由于根结点没有双亲，约定将根结点的位置域设成-1。

双亲表示法，可以很容易找到结点的双亲结点，所用的时间复杂度为O(1)，但是如果要知道结点的孩子是什么，需要遍历整个结构。在这种情况下，可以增加一个结点最左边孩子的域，这样可以很容易找到结点的孩子，如果没有孩子，则这个域设置成-1。

|data|parent|firstchild|
|-|-|-|

对于有0个或者1个孩子的结点来说，这种结构解决了找结点孩子的问题。

当关注兄弟之间的关系时，可以增加一个右兄弟域来体现兄弟关系，如果没有右兄弟，则赋值为-1

|data|parent|rightsib|
|-|-|-|

### 孩子表示法

由于树中每个结点可能有很多棵子树，可以考虑使用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，把这种方法叫做多重链表表示法。

|data|child1|child2|...|childd|
|-|-|-|-|-|

`data`是数据域，`child1~childd`是指针域，用来指向该结点的孩子结点。但是这种方法对于树中各个结点的度相差很大时，显然比较浪费空间，因为有很多的结点，它的指针域都是空的。

使用下面一种方案

每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数

|data|degree|child1|child2|...|childd|
|-|-|-|-|-|-|

`data`为数据域，`degree`为度域，也就是存储该结点的孩子结点的个数，`child1~childd`为指针域，指向该结点的孩子结点。

这种方法克服了浪费空间的缺点。但是由于各个结点的链表是不同的结构。加上要维护结点的度的值，在运算上就会带来时间的损耗。

> 孩子表示法：将每个结点放到一个顺序存储结构的数组中，再对每个结点的孩子建立一个单链表体现它们的关系。
> 
> 把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表。如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一维数组中。


    #define MAX_TREE_SIZE 100

    typedef int TElemType;

    typedef struct CTNode               //孩子结点
    {
        int child;                      //数据域，用来存储某结点在表头数组中的下标
        struct CTNode *next;            //指向某结点的下一个孩子结点的指针
    }*ChildPtr;

    typedef struct                      //表头结构
    {
        TElemType data;                 //数据域，存储某结点的数据信息
        ChildPtr firstchild;            //头指针域，存储该结点的孩子链表的头指针
    }CTBox;

    typedef struct                      //树结构
    {
        CTBox nodes[MAX_TREE_SIZE];     //结点数组
        int r,n;                        //根的位置和结点数
    }CTree;

这种结构对于查找某个结点的孩子结点或者兄弟很方便，只需要查找孩子单链表。遍历整棵树也很方便，对于头结点的数组循环即可。但是要查找某个结点的双亲就比较麻烦，需要整棵树遍历才行。

### 孩子兄弟表示法

从兄弟的角度考虑表示树，但是光从兄弟的层级研究是不够的，还需要加上孩子结点。

|data|firstchild|rightsilb|
|-|-|-|

`data`是数据域，`firstchild`为指针域，存储该结点的第一个孩子结点的存储地址，`rightsilb`是指针域，存储该结点的右兄弟结点的存储地址。

    typedef struct CSNode
    {
        TElemType data;
        struct CSNode *firstchild, *rightsilb;
    }CSNode, *CSTree;

## 二叉树的定义


> 二叉树：是n(n>=0)个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

二叉树的特点：
1. 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。（最多有两棵。没有或者一棵子树都是可以的。）
2. 左子树和右子树都是有顺序的。
3. 即使树中结点只有一棵子树，也要区分它是左子树还是右子树。

二叉树具有五种基本形态：
1. 空二叉树
2. 只有一个根结点
3. 根结点只有左子树
4. 根结点只有右子树
5. 根结点既有左子树又有右子树

|特殊二叉树|说明|
|-|-|
|斜树|所有结点都只有左子树的二叉树叫做左斜树。所有结点都只有右子树的二叉树叫做右斜树。两者统称为斜树。线性表可以看做是一种特殊的斜树。|
|满二叉树|在一棵二叉树中，如果所有的分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树叫做满二叉树。特点：<li>叶子只能出现在最下一层。出现在其他层就不可能达到平衡；<li>非叶子结点的度一定是2；<li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多；|
|完全二叉树|对一个具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<li>满二叉树一定是一棵完全二叉树，但是完全二叉树不一定是满的。<li>叶子结点只能出现在最下两层；<li>最下层的叶子一定集中在左部连续位置；<li>倒数第二层，若有叶子结点，一定都在右部连续位置；<li>如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况；<li>同样结点数的二叉树，完全二叉树的深度最小。|


判断是否为完全二叉树的方法：给每个结点按照满二叉树结构逐层顺序编号，如果编号出现空档，则不是完全二叉树，否则就是。

## 二叉树的性质

1. 在二叉树的第i层至多有$2^{i-1}$个结点
2. 深度为k的二叉树至多有$2^k-1$个结点（k>=1）
3. 对任何一棵二叉树T，如果其终端结点数(叶子结点数)为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$
4. 具有n个结点的完全二叉树的深度为$[log_2n]+1$，[x]表示不大于x的最大整数
5. 如果一棵有n个结点的完全二叉树（深度为$[log_2n]+1$）的结点按层序编号（从第1层到第$[log_2n]+1$层，每层从左到右），对于任一结点i（1<=i<=n）有：
   1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点[i/2]
   2. 如果2i>n，则结点i无左孩子，结点i为叶子结点；否则其左孩子是结点2i
   3. 如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1。

## 二叉树的存储结构

### 二叉树的顺序存储结构

二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。


顺序存储结构一般只用于完全二叉树，其他的二叉树可能会造成存储空间的浪费。

### 二叉链表

|lchild|data|rchild|
|-|-|-|
`data`是数据域，`lchild`和`rchild`都是指针域，分别指向左孩子和右孩子的指针。

    typedef struct BiTNode
    {
        TElemType data;                         //结点数据
        struct BiTNode *lchild, *rchild;        //左右孩子指针
    }BiTNode, *BiTree;


## 遍历二叉树

二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。


### 前序遍历法

> 规则：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。

    //前序递归遍历T
    void PreOrderTraverse(BiTree T)
    {
        if(T==NULL)
        {
            return;
        }
        printf("%c\n", T->data);            //显示结点数据，可以更改为对其他结点的操作
        PreOrderTraverse(T->lchild);        //先序遍历左子树
        PreOrderTracerse(T->rchild);        //先序遍历右子树
    }

### 中序遍历法

> 规则：若树为空，则空操作返回，否则从根结点开始（注意不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。

    //中序递归遍历T
    void InOrderTraverse(BiTree T)
    {
        if(T==NULL)
        {
            return;
        }
        InOrderTraverse(T->lchild);         //中序遍历左子树
        printf("%c\n", T->data);            //显示结点数据，可以更改为其他对结点的操作
        InOrderTraverse(T->rchild);         //中序遍历右子树

    }

### 后序遍历法

> 规则：若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。

    //后序递归遍历T
    void PostOrderTraverse(BiTree T)
    {
        if(T==NULL)
        {
            return;
        }
        PostOrderTraverse(T->lchild);           //后序遍历左子树
        PostOrderTraverse(T->rchild);           //后序遍历右子树
        printf("%c\n", T->data);                //显示结点数据，可以更改为其他对结点的操作   
    }


### 层序遍历

> 规则：若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按照从左到右的顺序对结点逐个访问。

### 推导遍历结果

已知一棵二叉树的前序遍历序列和中序遍历序列，求这棵二叉树的后序遍历序列。

具体只要了解各个算法的步骤，就可以推导出

并由此可以得出二叉树的另外两个性质：
1. 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树
2. 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树
3. 已知前序和后序遍历，是不能唯一确定一棵二叉树的。

## 二叉树的建立

将二叉树中每个结点的空指针引出一个虚节点，其值为一特定值，比如'#'

    //按照前序输入二叉树中结点的值（一个字符）
    //#表示空树，构造二叉链表表示二叉树T
    void CreateBiTree(BiTree *T)
    {
        TElemType ch;

        scanf("%c", &ch);
        ch = str[index++];

        if(ch=='#')
        {
            *T = NULL;
        }
        else
        {
            *T = (BiTree)malloc(sizeof(BiNode));
            if(!*T)
            {
                exit(OVERFLOW);
            }
            (*T)->data = ch;                //生成根结点
            CreateBiTree(&(*T)->lchild);    //构造左子树
            CreateBiTrss(&(*T)->rchild);    //构造右子树
        }
    }

## 线索二叉树

二叉链表存在空指针域，会占用内存。另一方面，在做遍历的时候，可以知道任意一个节点的前驱和后继是哪一个结点。在二叉链表上，只能知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱是谁，后继是谁。想要知道必须要遍历一次。

> 将指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。