# 串

> 串：由零个或者多个字符组成的有限序列，又叫做字符串。

串中字符数目的n称为串的长度。零个字符的串称为空串。


## 串的比较

给定两个串$s=a_1a_2...a_n$，$t=b_1b_2...b_m$，当满足下列条件之一时，$s<t$
1. $n<m$且$a_i=b_i(i=1,2,...n)$
2. 存在某个$k<=min(m,n)$，使得$a_i=b_i(i=1,2,...k-1), a_k<b_k$

## 串的抽象数据类型

    ADT 串（String）
    Data
        串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
    Operation
        StrAssign(T, *chars):生成一个其值等于字符串常量chars的串T
        StrCopy(T,S):串S存在，由串S复制得串T
        ClearString(S):串S存在，将串清空
        StringEmpty(S):若串S为空，则返回true，否则返回false
        StrLength(S):返回串S的元素个数，即串的长度
        StrCompare(S,T):若S>T，返回值>0，若S=T，返回值0，若S<T，返回值<0
        Concat(T, S1, S2):用T返回由S1和S2连接而成的新串
        SubString(Sub,S,pos,len):串S存在，1<=pos<=StrLength(S)，
                                    且0<=len<=StrLength(S)-pos+1，
                                    用Sub返回串S的第pos个字符起长度为len的子串
        Index(S,T,pos):串S和T存在，T是非空串，1<=pos<=StrLength(S)。若主串S中存在
                                和串T值相同的子串，则返回它在主串S中第pos个字符
                                之后第一次出现的位置。否则返回0。
        Replace(S,T,V):串S，T，V存在，T是非空串。用V替换主串中出现的所有与T相同的
                        不重叠的子串。
        StrInsert(S,pos,T):串S和T存在，1<=pos<=StrLength(S)+1，
                        在串S的第pos个字符之前插入串T
        StrDelete(S,pos,len):串S存在，1<=pos<=StrLength(S)-len+1。
                            从串S中删除第pos个字符起长度为len的子串
    endADT

## 串的存储结构

### 串的顺序存储结构

串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。一般可以将实际的串的长度值保存在数组的0下标位置。

### 串的链式存储结构

串的链式存储结构，与线性表类似，但是如果一个节点存放一个字符，就会造成很大的浪费。因此一个节点可以存放多个字符。串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。


## 朴素的模式匹配算法

> 子串的定位操作通常称为串的模式匹配。

朴素的模式匹配算法，简单的说就是对于主串的每一个字符做为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做子串长度的小循环，知道匹配成功或者全部遍历完成位置为止。



    //返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。
    //其中，T非空，1<=pos<=StrLength(S)
    int Index(String S, String T, int pos)
    {
        int i = pos;                            //i用于主串S中当前位置下标，从pos位置开始匹配
        int j = 1;                              //j用于子串T中当前位置下标
        while(i <= S[0] && j <= T[0])           //当i小于S的长度并且j小于T的长度是，循环继续
        {
            if(S[i] == T[j])                    //两字母相等则继续
            {
                ++i;
                ++j;
            }
            else                                //指针后退重新开始匹配
            {
                i = i-j+2;                      //i退回到上次匹配首位的下一位
                j = 1;                          //j退回子串T的首位
            }
        }
        if(j > T[0])
        {
            return i-T[0];
        }
        else 
        {
            return 0;
        }
    }

朴素的模式匹配最坏的时间复杂度为$O((n-m+1)*m)$

## KMP模式匹配算法

KMP模式匹配算法可以大大避免重复遍历的情况。

- 情况1：

假设$S=abcdefgad$，$T=abcdex$。如果按照朴素的模式匹配算法，就需要一次次遍历$S$和$T$。

在知道$T$中的首字符$a$与$T$中的后面的字符均不相等的前提下，$T$串的$a$与$S$串后面的$c$,$d$,$e$也可以在第一次遍历之后确定是不相等的。所以可以节省掉一些遍历的步骤。虽然$T[1]!=T[6]$。但是不能断定$T[1]$一定不等于$S[6]$。因此需要保留该步的遍历。

- 情况2：

假设$S=abcababca$，$T=abcabx$。因为$T$和$S$的前5个字符相等，第6个字符不相等。根据刚才的经验，$T$的首字符和第二位$b$，第三位$c$均不相等，所以不需要做判断。

因为$T$的首位$a$与$T$的第四位$a$相等，第二位的$b$与第五位的$b$相等。在第一次遍历时，$T$的第4位和第5位的已经和主串$S$中的相应位置比较过了，是相等的。因此可以断定，$T$的首字符$a$，第二位的字符$b$与$S$的第四位和第五位字符也不需要比较，可以省略。也就是说，对于在**子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。**


KMP模式匹配算法就是为了让这种没有必要的回溯不发生。i值不回溯，就是不可以变小，考虑的就是j值，因为要考虑T串中的首字符与自身后面字符的比较，发现如果有相等字符，j的变化就不会相同，因此j值的变化与主串其实没有什么关系，关键就取决于T串中是否有重复的问题。

比如$T=abcdex$当中没有任何重复的字符，所以j就由6变成1了，第二个例子中$T=abcabx$，j由6变成了3，j的大小取决于当前字符之前的串的前后缀的相似度。


也就是说，在查找字符串之前，先对要查找的字符串做一个分析，这样可以大大减少查找的难度，提高查找的速度。 

将T串的各个位置j值的变化定义为一个数组next，那么next的长度就是T串的长度。

$$ next[j]=\left\{
\begin{aligned}
0&,  &当j=1\\
Max & =  \{k|1<k<j,且P_1...P_{k-1}=P_{j-k+1}...P_{j-1}\}, &当此集合不空时 \\
1&,&其他情况
\end{aligned}
\right.
$$

下面给出四个例子，推导next数组

|j|123456|
|-|-|
|模式串T|abcdex| 
|next[j]|011111|
1. 当j=1时，next[1]=0；
2. 当j=2时，j由1到j-1就只有字符a，属于其他情况next[2]=1；
3. 当j=3时，j由1到j-1串是ab，显然a和b不相等，属于其他情况，next[3]=1；
4. 以后同理，所以最后T串的next[j]为011111；

|j|123456|
|-|-|
|模式串T|abcabx|
|next[j]|011123|

1. 当j=1时，next[1]=0；
2. 当j=2时，同上例说明，next[2]=1；
3. 当j=3时，同上，next[3]=1；
4. 当j=4时，同上，next[4]=1；
5. 当j=5时，此时j由1到j-1的串是abca，前缀字符a与后缀字符a相等，由此可以推算出k值为2，因此next[5]=2
6. 当j=6时，j由1到j-1的串是abcab，由于前缀字符ab与后缀字符ab相等，所以next[6]=3；

由此可以根据经验得到如果前后缀一个字符相等，k值为2，两个字符相等k值是3，n个字符相等k值就是n+1。

|j|123456789|
|-|-|
|模式串T|ababaaaba|
|next[j]|011234223|
1. 当j=1时，next[1]=0；
2. 当j=2时，同上next[2]=1；
3. 当j=3时，同上next[3]=1；
4. 当j=4时，j由1到j-1的串是aba，前缀字符a与后缀字符a相等，next[4]=2；
5. 当j=5时，j由1到j-1的串是abab，前缀字符ab与后缀字符ab相等，所以next[5]=3；
6. 当j=6时，j由1到j-1的串是ababa，前缀字符aba与后缀字符aba相等，所以next[6]=4；
7. 当j=7时，j由1到j-1的串是ababaa，前缀字符ab与后缀字符ab并不相等，只有a相等，所以next[7]=2；
8. 当j=8时，j由1到j-1的串是ababaaa，只有a相等，所以next[8]=2；
9. 当j=9时，j由1到j-1的串是ababaaab，由于前缀字符ab与后缀字符ab相等，所以next[9]=3；

|j|123456789|
|-|-|
|模式串T|aaaaaaaab|
|next[j]|012345678|
1. 当j=1时，next[1]=0；
2. 当j=2时，next[2]=1;
3. 当j=3时，j由1到j-1的串是aa，前缀字符a与后缀字符a相等，next[3]=2；
4. 当j=4时，j由1到j-1的串是aaa，由于前缀字符aa与后缀字符aa相等，所以next[4]=3；
5. ...
6. 当j=9时，j由1到j-1的串是aaaaaaaa，由于前缀字符aaaaaaa与后缀字符aaaaaaa相等，所以next[9]=8；

## KMP模式匹配算法的代码实现

    //通过计算返回子串T的next数组
    void get_next(String T, int *next)
    {
        int i,k;
        i = 1;
        k = 0;
        next[1] = 0;
        while(i<T[0])                       //T[0]表示串T的长度
        {
            if(k==0 || T[i] == T[k])
            {
                ++i;
                ++k;
                next[i] = k;
            }
            else 
            {
                k = next[k];                //若字符不相同，则k值回溯
            }
        }
    }

    //返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数的返回值为0
    //T非空，1<=pos<=StrLength(S)
    int Index_KMP(String S, String T, int pos)
    {
        int i = pos;                    //i用于主串S中当前位置下标值，从pos位置开始匹配
        int j = 1;                      //j用于子串T中当前位置下标值
        int next[255];                  //定义一个next数组
        get_next(T,next);               //对串T进行分析，得到next数组
        while(i<=S[0] && j<=T[0])       //当i小于S的长度并且j小于T的长度时，循环继续
        {
            if(j==0 || S[i] == T[j])    //两字母相等则继续，与朴素算法相比增加了j=0的判断
            {
                ++i;            
                ++j;
            }
            else                        //指针后退重新开始匹配 
            {   
                j = next[j];            //j退回合适位置，i值不变
            }
        }
        if(j > T[0])
        {
            return i-T[0];
        }
        else 
        {
            return 0
        }
    }

KMP模式匹配算法仅当模式与主串之间存在许多部分匹配的情况下，才能体现出优势，否则与朴素模式匹配算法相比，两者差异并不明显。


## KMP模式匹配算法的改良

    //求模式串T的next函数修正值并存入数组nextval
    void get_nextval(String T, int *nextval)
    {
        int i,k;
        i=1;
        k=0;
        nextval[1] = 0;
        while(i<T[0])                       //T[0]表示串T的长度
        {
            if(k==0 || T[i] == T[k])        //T[i]表示后缀的单个字符，T[k]表示前缀的单个字符
            {
                ++i;
                ++k;
                if(T[i]!=T[k])              //若当前字符与前缀字符不相同
                {
                    nextval[i] = k;         //则当前的k为nextval在i位置的值
                }
                else 
                {
                    nextval[i] = nextval[k];    //如果与前缀字符相同，则将前缀字符的nextval值赋值给nextval在i位置的值
                }
            }
            else 
            {
                k = nextval[k];                //若字符不相同，则k值回溯
            }
        }
    }

实际的匹配算法，只需要将`get_next(T, next);`改成`get_nextval(T, next);`

|j|123456789|
|-|-|
|模式串T|ababaaaba|
|next[j]|011234223|
|nextval[j]|010104210|

1. 当j=1时，nextval[1]=0;
2. 当j=2时，因第二位字符b的next值是1，而第一位是a，它们不相等，所以nextval[2]=next[2]=1，维持原值。
3. 当j=3时，因为第三位字符a的next值是1，所以与第一位的a比较得知他们相等，所以nextval[3]=nextval[1]=0；
4. 当j=4时，第四位的字符b的next值是2，所以与第二位的b相比较得到结果相等，因此nextval[4]=nextval[2]=1；
5. 当j=5时，next值为3，第5个字符a与第3个字符a相等，因此nextval[5]=nextval[3]=0;
6. 当j=6时，next值为4，第6个字符a与第4个字符b不相等，因此nextval[6]=4;
7. 当j=7时，next值为2，第7个字符a与第2个字符b不相等，因此nextval[7]=2;
8. 当j=8时，next值为2，第8个字符b与第2个字符b相等，因此nextval[8]=nextval[2]=1;
9. 当j=9时，next值为3，第9个字符a与第3个字符a相等，因此nextval[9]=nextval[3]=0;

|j|123456789|
|-|-|
|模式串T|aaaaaaab|
|next[j]|012345678|
|nextval[j]|000000008|

1. j=1时，nextval[1]=0；
2. 当j=2时，next值为1，第二个字符与第一个字符相等，所以nextval[2]=nextval[1]=0；
3. 同样的道理，其后都是0
4. 当j=9时，next值为8，第九个字符b与第八个字符a不相等，所以nextval[9]=8。

总结改进过的KMP算法，它是在计算出next值的同时，如果a位字符与它next
值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不相等，则该a位的nextval值就是它自己a位的next的值。