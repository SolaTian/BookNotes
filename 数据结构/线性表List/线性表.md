# 线性表

> 线性表：零个或者多个数据元素的有限序列

特点：
- 有限性
- 有序性

线性表记为（$a_1$,...,$a_{i-1}$,$a_i$,$a_{i+1}$,...,$a_n$）

其中$a_{i-1}$是$a_i$的直接前驱元素，$a_{i+1}$是$a_i$的直接后驱元素。


## 线性表的抽象数据类型

    ADT List
    Data
        线性表数据集合
    Operation
        InitList(*L)：初始化操作，建立一个空的线性表L
        ListEmpty(L)：若线性表为空，则返回true，否则返回false
        ClearList(*L)：将线性表清空
        GetElem(L, i, *e)：将线性表L的第i个位置元素值返回给e
        LocateElem(L, e)：在线性表L中查找与给定值e相等的元素，如果查找成功，
                            返回该元素在表中序号表示成功；否则，返回0表示失败。
        ListInsert(*L, i, e)：在线性表L中的第i个位置插入新元素e
        ListDelete(*L, i, *e)：删除线性表L中的第i个位置元素，并用e返回其值。
        ListLength(L)：返回线性表L的元素个数
    endADT

## 线性表的顺序存储结构

> 线性表的顺序存储结构：指的是用一段地址连续的存储单元依次存储线性表的数据元素。

在C语言中，使用一维数组来实现顺序存储结构

    #define MAXSIZE 20
    typedef int ElemType;
    typedef struct
    {
        ElemType data[MAXSIZE];         //数组，存储数据元素
        int length;                     //线性表的当前长度
    }Sqlist;

线性表的长度是线性表中数据元素的个数，这个数量随着插入和删除，是在变化的，因此线性表的长度应该小于等于数组的长度。

线性表中第i个元素要存储在数组下标为i-1的位置。


顺序存储结构中，知道其中一个元素的位置，就可以知道任意一个元素的位置

$$Locate(a_{i+1})=Locate(a_i)+c$$

其中$c$是指占用了$c$个存储单元。

这种存储结构的存取时间性能为O(1)，也称为随机存储结构。

## 顺序存储结构的插入和删除

### 获取元素操作

    #define OK  1
    #define ERROR 0
    tyepedef int Status;

    /*
    **顺序线性表已经存在，1<=i<=ListLength(L)
    **用e返回L中第i个数据元素的值    
    */
    Status GetElem(SqList L, int i, ElemType *e)
    {
        if(L.length==0 || i<1 || i>L.length)
        {
            return ERROR;
        }
        *e = L.data[i-1];

        return OK;
    }     

### 插入操作

插入算法的思路：
1. 如果插入的位置不正常，则抛出异常
2. 如果线性表长度大于等于数组长度，则抛出异常或者动态增加容量
3. 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置
4. 将要插入元素填入位置i处
5. 表长加1

代码实现如下：

    /*
    **初始条件：顺序线性表L已经存在，1<=i<=ListLength(L)
    **操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1  
    **注意：第i个位置对应的是顺序线性表的第i-1个元素
    */

    Status ListInsert(SqList *L, int i, ElemType e)
    {
        int k;
        if(L->length == MAXSIZE)                    //线性表已满
        {
            return ERROR;
        }
        if(i<1 || i>L->length+1)                    //当i比第一位置小或者最后一位之后一位还要大时
        {
            return ERROR;
        }

        if(i<=L->length)                        //插入的位置不在表尾
        {
            for(k=L->length-1; k>=i-1; k--)     //将要插入位置后的元素向后移一位
            {
                L->data[k+1]=L->data[k];
            }
        }
        L->data[i-1]=e;                         //将新元素插入
        L->length++;

        return OK;
    }



### 删除操作

删除算法的思路：
1. 如果删除位置不合理，则抛出异常
2. 取出删除元素
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
4. 表长减1

代码实现如下：

    /*
    **初始条件：顺序线性表L已经存在，1<=i<=ListLength(L)
    **操作结果：删除L的第i个元素，并用e返回其值，L的长度减1
    */

    Status ListDelete(SqList *L, int i, ElemType *e)
    {
        int k;
        
        if(L->length == 0)              //线性表为空
        {
            return ERROR;
        }

        if(i<1 || i>L->length)          //删除位置不正确
        {
            return ERROR;
        }

        *e = L->data[i-1];              //存储要删除的值
        if(i<L->length)                 //如果删除的位置不是最后的位置
        {
            for(k=i; k<L->length; k++)  //将删除位置后继的元素向后移
            {
                L->data[k-1] = L->data[k];
            }
        }
        L->length--;
        return OK;
    }

其他的关于线性表的方法，见`线性表顺序存储.c文件`

### 线性表顺序存储结构的优缺点

|||
|-|-|
|优点|<li>无需为表中元素之间的逻辑关系增加额外的存储空间；<li>可以快速存取表中任一位置的元素|
|缺点|<li>插入和删除操作需要移动大量元素；<li>当线性表长度变化较大时，难以确定存储空间的容量；<li>造成存储空间的碎片|

## 线性表的链式存储结构

线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。

相关术语：

> 数据域：存储数据元素的叫做数据域
>
> 指针域：存储直接后继位置的域
>
> 指针：指针域中存储的信息
>
> 结点：指针域和数据域两部分信息组成的数据元素

n个结点链接成一个链表，即为线性表的链式存储结构。因为此链表的每个节点中只包含一个指针域，所以叫做单链表。

> 头指针：链表中的第一个节点的存储位置叫做头指针。

> 头结点：为了方便操作，在单链表的第一个节点前附设一个节点，称为头结点，头结点的数据域可以不存储任何信息，也可以存储线性表的长度等附加信息。头结点的指针存储指向第一个结点的指针。


 
- 头结点是为了操作的统一和方便设立。

|头指针|头结点|
|-|-|
|<li>头指针就是链表的名称，仅仅是一个指针而已；<li>若链表有头结点，则是指向头结点的指针；<li>不论链表是否为空，头指针均不为空。头指针是链表的必要元素|<li>有了头结点，对于在第一元素结点前插入结点和删除第一结点，操作就与其他的结点的操作统一了；<li>头结点不一定是链表必要元素|

最后一个节点指针为空`NULL`，不指向任何一个地方。


    typedef struct Node 
    {
        ElemType data;
        struct Node *next;
    }Node;
    typedef struct Node *LinkList;


若线性表为空表，则头结点的指针域为空。

## 单链表的读取

获取链表的第i个数据的算法思路：
1. 声明一个指针p指向链表的第一个结点，初始化j从1开始
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
3. 当到链表末尾p为空，则说明第i个结点不存在
4. 否则查找成功，返回结点p的数据。

代码如下

    /*
    **初始条件：链式线性表L已存在，1<=i<=ListLength(L)
    **操作结果：用e返回L中第i个数据元素的值
    */
    Status GetElem(LinkList L, int i, ElemType *e)
    {
        int j;
        LinkList p;                 //声明一个结点
        p = L->next;                //让p指向链表L的第一个结点
        j = 1;                      //j为计数器
        while(p && j<i)
        {
            p = p->next;            //让p指向下一个结点
            ++j;
        }

        if(!p || j>i)
        {
            return ERROR;           //第i个元素不存在
        }
        *e = p->data;               //取第i个元素的数据
        return OK;
    }

由于单链表没有定义表长，因此不能用for循环，核心思想就是工作指针后移。

## 单链表插入与删除

插入算法实现思路：
1. 声明一个指针p指向链表的头结点，初始化从j开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1
3. 若到链表末尾p为空，则说明第i个结点不存在
4. 否则查找成功，在系统中生成一个空结点s
5. 将数据元素e赋值给s->data
6. 单链表的插入标准语句：`s->next = p->next; p->next = s;`
7. 返回成功

代码实现如下

    /*
    **初始条件：链式线性表L已存在，1<=i<=ListLength(L)
    **操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1
    */
    Status ListInsert(LinkList *L, int i, ElemType e)
    {
        int j;
        LinkList p,s;
        p = *L;
        j = 1;
        while(p && j < i)                       //寻找第i个结点
        {
            p = p->next;                
            ++j;
        }

        if(!p || j>i)
        {
            return ERROR;
        }

        s = (LinkList)malloc(sizeof(Node));     //生成新结点
        s->data = e;
        s->next = p->next;                      //将p的后继节点赋值给s的后继
        p->next = s;                            //将s赋值给p的后继
        return OK;  
    }

注意插入的标准语句不能够颠倒顺序，否则会失去`p->next`的寻址方式



删除算法实现思路：
1. 声明一个指针p指向链表的头结点，初始化j从1开始
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3. 若到链表末尾p为空，则说明第i个结点不存在
4. 否则查找成功，将欲删除的结点p->next赋值给q；
5. 单链表的删除标准语句`p->next=q->next;`
6. 将q结点中的数据赋值给e，作为返回
7. 释放q结点
8. 返回成功

代码实现如下：

    /*
    **初始条件：链式线性表L已存在，1<=i<=ListLength(L)
    **操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1
    */
    Status ListDelete(LinkList *L, int i, ElemType *e)
    {
        int j;
        LinkList p, q;
        p = *L;
        j = 1;
        while(p->next && j < i)                 //遍历寻找第i个元素
        {
            p = p->next;
            ++j;
        }

        if(!(p->next) || j > i)
        {
            return ERROR;                       //第i个元素不存在
        }

        q = p->next;                            
        p->next = q->next;                      //将q的后继赋值给p的后继
        *e = q->data;                           //将q结点中的数据给e
        free(q);                                //释放
        return OK;
    }

## 单链表的整表创建

单链表整表创建的思路：
1. 声明一个指针p和计数器变量i
2. 初始化一空链表L
3. 让L的头结点的指针指向NULL，即建立一个带头结点的单链表
4. 循环
   1. 生成一个新结点赋值给p
   2. 随机生成一数字赋值给p的数据域p->data
   3. 将p插入到头结点与前一新结点之间
   
代码实现如下：

    /*
    **头插法：随机生成n个元素的值，建立带表头结点的单链线性表L
    */
    void CreateListHead(LinkList *L, int n)
    {
        LinkList p;
        int i;
        srand(time(0));                         //初始化随机数种子

        *L = (LinkList)malloc(sizeof(Node));
        (*L)->next = NULL;                      //先建立一个带头结点的单链表
        for(i=0; i<n; i++)
        {
            p = (LinkList)malloc(sizeof(Node)); //生成新结点
            p->data = rand()%100+1;             //随机生成100以内的数字
            p->next = (*L)->next;   
            (*L)->next = p;                     //插入到表头
        }
    }

这种插入方式，始终让新结点在第一的位置，因此叫做头插法。


尾插法代码实现：

    /*
    **尾插法：随机生成n个元素的值，建立带表头结点的单链线性表L
    */
    void CreateListTail(LinkList *L, int n)
    {
        LinkList p,r;
        int i;
        srand(time(0));                             //初始化随机种子
        *L = (LinkList)malloc(sizeof(Node));        //L为整个线性表
        r = *L;                                     //r为指向尾部的结点
        for(i=0; i<n; i++)
        {
            p = (Node *)malloc(sizeof(Node));       //生成新结点
            p->data = rand()%100+1;                 //随机生成100以内的数字
            r->next = p;                            //将表尾终端节点的指针指向新结点
            r = p;                                  //将当前的新结点定义为表尾终端节点
        }
        r->next = NULL;                             //表示当前链表结束
    }

## 单链表的整表删除

单链表的整表删除的算法思路:
1. 声明一指针p和q
2. 将第一个结点赋值给p
3. 循环
   1. 将下一个结点赋值给q
   2. 释放p
   3. 将q赋值给p

代码实现如下：

    /*
    **初始条件：链式线性表L存在。操作结果：将L重置为空表
    */
    Status ClearList(LinkList *L)
    {
        LinkList p,q;
        p = (*L)->next;                     //p指向第一个结点
        while(p)                            //没有到表尾
        {
            q = p->next;
            free(p);
            p = q;
        }
        (*L)->next = NULL;                  //头结点指针域为空
        return OK;
    }

## 单链表结构和顺序存储结构的优缺点

||顺序存储结构|链式存储结构|
|-|-|-|
|存储分配方式|采用一段连续存储单元依次存储线性表的数据元素|用一组任意的存储单元存放线性表的元素|
|时间性能|<li>查找：`O(1)`；<li>插入和删除：需要平均移动表长一半的元素，时间复杂度为`O(n)`|查找：`O(n)`；<li>插入和删除：找出位置的指针后，插入和删除时间复杂度为`O(1)`|
|空间性能|需要预分配存储空间，容易造成浪费|单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制|

若线性表需要频繁查找，很少进行插入和删除的操作，宜采用顺序存储结构；若需要频繁的插入和删除，则宜采用链式存储结构。当线性表中的元素个数变化较大或者根本不知道有多大时，最好采用单链表结构。


## 静态链表

> 静态链表：使用数组描述的链表叫做静态链表。

数组中的每个下标都对应着一个`data`和一个`cur`。数据域`data`，用来存放数据元素，`cur`相当于单链表的`next`指针。




    #define MAXSIZE 1000

    typedef struct 
    {
        ElemType data;
        int cur;                //游标，为0时表示无指向
    }Component,StaticLinkList[MAXSIZE];

通常将未被使用的数组元素称为备用链表。而数组的第一个元素，即下标为0的元素的`cur`就存放备用链表的第一个结点的下标；而数组的最后一个元素的`cur`则存放第一个有数值的元素的下标，相当于单链表中头结点的作用。当整个链表为空时，则为0。

![](https://images2018.cnblogs.com/blog/1363350/201805/1363350-20180510134856602-1177840860.png)

[参考链接](https://www.cnblogs.com/tonbby/p/9019117.html)

    /*将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，0表示空指针*/
    Status InitList(StaticLinkList space)
    {
        int i;
        for(i=0; i<MAXSIZE-1; i++)
        {
            space[i].cur = i+1;
        }
        space[MAXSIZE-1].cur = 0;           //目前静态链表为空，最后一个元素的cur为0
    }

## 静态链表的插入操作

为了辨明数组中哪些分量没有被使用，解决的方法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。

    /*若备用空间链表非空，则返回分配的结点下标，否则返回0*/
    int Malloc_SSL(StaticLinkList space)
    {
        int i = space[0].cur;               //当前数组的第一个元素的cur存的值
                                            //就是要返回的第一个备用空闲的下标
        if(space[0].cur)
        {
            space[0].cur = space[i].cur;    //由于要分配一个分量来使用
                                            //于是就将它的下一个分量用来做备用
        }

        return i;
    }


    Status ListInsert(StaticLinkList L, int i, ElemType e)
    {
        int j,k,l;
        k = MAXSIZE - 1;                    //k是最后一个元素的下标
        if(i<1 || i>ListLength(L) + 1)
        {
            return ERROR;
        }
        j = Malloc_SSL(L);                  //获得空闲分量的下标
        if(j)
        {
            L[j].data = e;                  //将数据赋值给此分量的data
            for(l=1; l<=i-1; l++)
            {
                k = L[k].cur;               //找到第i个元素之前的位置
            }
            L[j].cur = L[k].cur;            //把第i个元素之前的cur赋值给新元素的cur
            L[k].cur = j;                   //把新元素的下标赋值给第i个元素之前的元素的cur
            return OK;
        }
        return ERROR;
    }

这样就可以实现不移动元素，却插入了数据的操作。

## 静态链表的删除操作

    /*删除在L中的第i个数据元素*/
    Status ListDelete(StaticLinkList L, int i)
    {
        int j,k;
        if(i<1 || i>ListLength(L))
        {
            return ERROR;
        }

        k = MAXSIZE-1;
        for(j=1; j<=i-1; j++)
        {
            k = L[k].cur;
        }
        j = L[k].cur;
        L[k].cur = L[j].cur;
        Free_SSL(L, j);
        return OK;
    }

    /*将下标为k的空闲结点回收到备用链表*/
    void Free_SSL(StaticLinkList space, int k)
    {
        space[k].cur = space[0].cur;            //把第一个元素的cur值赋给要删除的分量cur
        space[0].cur = k;                       //把要删除的分量下标赋值给第一个元素的cur
    }


    /*初始条件：静态链表L已经存在，操作结果：返回L中的数据元素的个数*/
    int ListLength(StaticLinkList L)
    {
        int j=0;
        int i = L[MAXSIZE-1].cur;
        while(i)
        {
            i = L[i].cur;
            j++;
        }
        return j;
    }

## 静态链表的优缺点

|静态链表|说明|
|-|-|
|优点|插入和删除元素，只需要修改游标，不需要移动元素，改进了在顺序存储结构中插入和删除大量元素的缺点|
|缺点|没有解决连续存储分配带来的表长难以确定的问题；失去了链式存储结构随机存取的特性|

静态链表其实是为了给没有指针的编程语言设计的一种实现单链表功能的方法。

## 循环链表

> 将单链表中的终端结点的指针端由空指针改为指向头结点，就使得整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。

循环链表和单链表的主要差异在于循环的判断条件上，单链表是判断`p->next`是否为空，现在是`p->next`不等于头结点，则循环未结束。

循环链表使用指向终端结点的尾指针`rear`来表示循环链表。

将两个循环链表合并成一个表时，它们的尾指针分别为`rearA`和`rearB`

    p = rearA->next;                    //保存A的头结点
    rearA->next = rearB->next->next;    //将原本指向B的第一个结点(不是头结点)赋值给rearA->next

    q = rearB->next;
    rearB->next = p;                    //将原A表的头结点赋值给rearB->next
    free(q);                            //释放q

## 双向链表

> 双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。

双向链表中的结点都有两个指针域，一个指向直接后继，一个指向直接前驱。


    typedef struct DulNode
    {
        ElemType data;
        struct DulNode *prior;          //直接前驱指针
        struct DulNode *next;           //直接后继指针
    }DulNode, *DuLinkList;

双向链表的求长度`ListLength`，查找元素`GetElem`，获得元素位置的`LocateElem`等，这些操作都只涉及一个方向的指针，另一个指针提供不了什么帮助，实现和单链表几乎是相同的。


但是在插入和删除时，需要更改两个指针变量。

![](https://img.jbzj.com/file_images/article/202205/2022052310452351.png)
[参考链接](https://www.jb51.net/article/248959.htm)

插入实现：

    s->prior = p;               //将p赋给s的前驱，如图1
    s->next = p->next;          //将p->next赋值给s的后继，如图2
    p->next->prior = s;         //将s赋值给p->next的前驱，如图3
    p->next = s;                //将s赋值给p的后继，如图4


![](https://img.jbzj.com/file_images/article/202205/2022052310452352.png)

删除实现：

    p->prior->next = p->next;       //将p->next赋值给p->proir的后继，如图1
    p->next->prior = p->prior;      //把p->prior赋值给p->next的前驱，如图2
    free(p);

双向链表通过使用空间来换取时间，提高了算法的时间性能。

## 总结

线性表：
1. 顺序存储结构
2. 链式存储结构
   1. 单链表
   2. 静态链表
   3. 循环链表
   4. 双向链表