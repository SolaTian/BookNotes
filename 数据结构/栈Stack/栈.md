# 栈

> 栈：限定在表尾进行插入和删除操作的线性表。
>
> 栈顶：允许插入和删除的一端称为栈顶，另一端称为栈底。不含有任何数据元素的栈称为空栈。栈又称后进先出的线性表。


## 栈的抽象数据类型

    ADT Stack
    Data
        同线性表。元素具有相同的类型，相邻元素之间具有前驱和后继关系。
    Operation
        InitStack(*S):初始化操作，建立一个空栈S
        DestroyStack(*S):若栈存在，则销毁它
        ClearStack(*S):将栈清空
        StackEmpty(S):若栈为空，则返回true，否则返回false
        GetTop(*S, e):若栈存在且非空，用e返回S的栈顶元素
        Push(*S, e):若栈S存在，插入新元素e到栈S中并成为栈顶元素
        Pop(*S, *e):删除栈S中栈顶元素，并用e返回其值
        StackLength(S):返回栈S的元素个数
    endADT

## 栈的顺序存储结构

    typedef int SElemType;          

    //顺序栈结构
    typedef struct 
    {
        SElemType data[MAXSIZE];
        int top;                        //用于栈顶指针 
    }SqStack;

## 栈的顺序存储结构——入栈

    Status Push(SqStack *S, SElemType e)
    {
        if(S->top == MAXSIZE-1)             //满栈
        {
            return ERROR;
        }
        S->top++;                           //栈顶指针加1
        S->data[S->top]=e;                  //将新插入元素赋值给栈顶空间
        return OK;
    }


## 栈的顺序存储结构——出栈

    Status Pop(SqStack *S, SElemtype *e)
    {
        if(S->top == -1)                    //空栈
        {
            return ERROR;
        }
        *e = S->data[S->top];               //将要删除的栈顶元素赋值给e
        S->top--;                           //栈顶指针减1
        return OK;
    }

出栈和入栈的时间复杂度均为O(1)

## 两栈共享空间

假设有两个相同类型的栈，其中一个栈满了，另一个栈还有很多存储空间空闲。可以利用一个数组来存储两个栈。

数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两个端点向中间延伸。

    typedef struct 
    {
        SElemType data[MAXSIZE];
        int top1;                       //栈1栈顶指针
        int top2;                       //栈2栈顶指针
    }

只要`top1`和`top2`不见面，两个栈就可以一直使用。满栈时，就是两个指针之间相差1时，即`top1`+1=`top2`时栈满。


入栈实现：

    Status Push(SqDoubleStack *S, SElemType e, int stackNumber)
    {
        if(S->top1+1 == S->top2)            //栈已满
        {
            return ERROR;
        }
        if(stackNumber == 1)                //栈1有元素进入
        {
            S->data[++S->top1] = e;         //栈1，则先top1+1后给数组元素赋值
        }else if(stackNumber == 2)          //栈2有元素进入
        {
            S->data[--S->top2] = e;         //栈2，则先top2-1后给数组元素赋值
        }
        return OK;
    }

出栈实现：

    Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber)
    {
        if(stackNumber == 1)                    //栈1空栈
        {
            if(S->top1 == -1)
            {
                return ERROR;
            }
            *e = S->data[S->top1--];            //将栈1的栈顶元素出栈 
        }else if(stackNumber == 2)
        {
            if(S->top2 == MAXSIZE)              //栈2空栈
            {
                return ERROR;
            }
            *e = S->data[S->top2++];            //将栈2的栈顶元素出栈 
        }
    }

## 栈的链式存储结构

通常对于链栈来说，是不需要头结点的。链栈基本不存在栈满的情况，除非内存不够，链栈的空其实就是`top=NULL`

    //链栈结构
    typedef struct StackNode 
    {
        SElemType data;
        struct StackNode *next;
    }StackNode, *LinkStackPtr;

    typedef struct 
    {
        ListStackPtr top;
        int count;
    }LinkStack;

链栈的操作绝大部分与单链表相似，只是在插入和删除上，特殊一些。

## 栈的链式存储结构——进栈操作

    //插入元素为e为新的栈顶元素
    Status Push(LinkStack *S, SElemType e)
    {
        LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
        s->data = e;
        s->next = S->top;                   //把当前的栈顶元素赋值给新结点的直接后继
        S->top = s;                         //将新的结点s赋值给栈顶指针
        S->count++;
        return OK;
    }

## 栈的链式存储结构——出栈操作

    //若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
    Status Pop(LinkStack *S, SElemType *e)
    {
        LinkStackPtr p;
        if(StackEmpty(*S))
        {
            return ERROR;
        }
        *e = S->top->data;                      
        p = S->top;                             //将栈顶结点赋值给p
        S->top = S->top->next;                  //使栈顶指针向下移一位，指向后一结点
        free(p);                                //释放结点p
        S->count--;
        return OK;
    }

如果栈的使用过程中元素变化不可预料，最好使用链栈，反之，如果变化过程在可控范围内，建议使用顺序栈。

## 栈的应用——递归

### 斐波那契数列的实现

使用迭代的方式实现斐波那契数列

    int main()
    {
        int i;
        int a[40];
        a[0] = 0;
        a[1] = 1;
        printf("%d ", a[0]);
        printf("%d ", a[1]);
        for(i=2; i<40; i++)
        {
            a[i] = a[i-1] + a[i-2];
            printf("%d ", a[i]);
        }
        return 0;
    }

使用递归来实现

    int Fbi(int i)
    {
        if(i<2)
        {
            return i == 0?0:1;
        }
        return Fbi(i-1)+Fbi(i-2);       //自己调用自己
    }

    int main()
    {
        int i;
        printf("递归显示斐波那契数列：\n");
        for(i = 0; i<10; i++)
        {
            printf("%d ", Fbi(i));
        }
        return 0;
    }

### 递归的定义

> 递归函数：把一个直接调用自己的函数或者通过一系列的调用语句间接调用自己的函数，叫做递归函数。

递归函数定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。

迭代和递归的区别：
- 迭代使用的是循环结构，递归使用的是选择结构。
- 大量的递归会调用建立函数的副本，会耗费大量的时间和内存。

递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这种数据结构，因此，编译器使用栈实现递归。

简单来说，在前行阶段，对于每一层递归，函数的局部变量，参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量，参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。


## 栈的应用——四则运算表达式求值





