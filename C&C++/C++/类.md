# 类

类的基本思想是数据抽象和封装。想要实现数据抽象和封装，需要先定义一个抽象数据类型。

当在调用成员函数时，其实是替某个对象调用它。成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。当调用一个成员函数时，用请求该函数的对象地址初始化`this`。

    total.isbn();

则编译器负责把`total`的地址传递给`isbn`的隐式形参`this`。

`this`形参是隐式的，任何自定义名为`this`的参数或者变量的行为都是非法的。可以在成员函数内部使用`this`。

## 定义Sales_data类


    struct Sales_data{
        std::string isbn() const {return bookNo;}
        Sale_data& combine(const Sales_data&);
        double avg_price() const;
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
    }

`isbn`函数的另一个关键之处是紧随参数列表之后的`const`关键字，这里，`const`的作用是修改隐式`this`指针的类型。

默认情况下，`this`的类型是指向类类型非常量版本的常量指针。例如在`Sales_data`成员函数中，`this`的类型是`Sales_data *const`。尽管`this`是隐式的，但是它仍然需要遵循初始化规则，意味着不能将`this`绑定到一个常量对象上。使得我们不能在一个常量对象上调用普通的成员函数。所以把`this`声明成`const Sales_data* const`，这样有助于提高函数的灵活性。

然而，`this`的声明是隐式的，C++的做法是允许把`const`关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的`const`表示`this`是一个指向常量的指针。这样使用`const`的成员函数被称做常量成员函数。

### 类的作用域和成员函数

成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。

#### 在类的外部定义成员函数

    double Sales_data::avg_price() const            //如果成员被声明为常量成员函数，需要指定const，且需要包含所属的类名
    {
        if(units_sold)
            return revenue/units_sold;
        else
            return 0;
    }

### 定义一个返回this对象的函数

    Sales_data& Sale_data::combine(const Sales_data &rhs)
    {
        units_sold += rhs.units_sold;               //把rhs的成员加到this对象的成员上
        revenue += rhs.revenue;
        return *this;                               //返回调用该函数的对象
    }

当调用函数时，

    total.combine(trans);                           //更新变量total当前的值

`return`语句解引用`this`指针以获得执行该函数的对象，换句话说，这个调用返回`total`的引用。   

## 构造函数

> 构造函数:初始化类对象的数据成员。

- 构造函数的名字与类名相同；
- 构造函数有一个可能为空的参数列表和一个可能为空的函数体；
- 构造函数没有返回类型；
- 类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有区别；
- 构造函数不可以被声明为const。

当创建类的一个`const`对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性，因此，构造函数在`const`对象的构造过程中可以向其写值。

### 合成的默认构造函数

如果类没有显示的定义构造函数，那么编译器就会隐式的定义一个默认构造函数，无须任何实参。

    struct Sales_data{
        Sales_data() = default;
        Sales_data(const std::string &s): bookNo(s){}
        Sales_data(const std::string &s, unsigned n, double p):
         bookNo(s), units_sold(n), revenue(p*n) {}
        Sales_data(std::istream &);
    }

`=defalut`表示是一个默认构造函数。定义这个构造函数的目的仅仅因为既需要其他形式的默认参数，也需要默认的构造函数。

`=default`既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。如果`=default`出现在类的内部，则默认构造函数是内联的；如果在类的外部，则该成员在默认情况下是不内联的。

### 构造函数初始值列表

    Sales_data(const std::string &s): bookNo(s){}
    Sales_data(const std::string &s, unsigned n, double p):
         bookNo(s), units_sold(n), revenue(p*n) {}

这两个构造函数，花括号定义了空的函数体，冒号和花括号之间的部分称为构造函数初始值列表，负责为新创建的对象的一个或者几个数据成员赋初值。每个名字后面紧跟括号括起来的成员初始值。

对于第一个构造函数，`units_sold`和`revenue`没有显示的初始化，因此将以默认构造函数相同的方式进行隐式初始化。就等价于

    Sales_data(const std::string &s): bookNo(s)
         units_sold(0), revenue(0){}

### 在类的外部定义构造函数

上面以`istream`为参数的构造函数

    Sales_data::Sales_data(std::istream &is)
    {
        read(is, *this);    //read函数的作用是从is中读取一条交易信息然后存入this对象
    }

这个构造函数虽然没有构造函数初始化列表，但是由于执行了构造函数体，对象的成员依然可以被初始化。

## 拷贝、赋值和析构

当编译器执行对象的赋值语句时，
    total = trans;
等同于下面的代码
    total.bookNo = trans.bookNo;
    total.units_sold = trans.units_sold;
    total.revrnue = trans.revenue;

## 访问控制与封装

### 访问说明符：    
1. `public`:该说明符之后的成员在整个程序内可以被访问，可以被其他类访问。`public`成员定义类的接口
2. `private`:该说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，`private`部分封装了类的实现细节

        class Sales_data{
        public:
            Sales_data() = default;
            Sales_data(const std::string &s, unsigned n, double p):
                bookNo(s), units_sold(n), revenue(p*n){}
            Sales_data(std::istream &);
            std::string isbn() const {return bookNo;}
            Sales_data &combine(const Sales_data&);
        private:
            double avg_price() const
                {return units_sold ? revenue/unit_sold:0;}
            std::string bookNo
            unsigned units_sold = 0;
            double revenue = 0.0;
        };

构造函数和部分成员函数紧跟在`public`说明符之后，而数据成员和实现部分的函数则跟在`private`后面。

### 使用class或者struct关键字

`class`和`struct`关键字的默认访问权限不一样。如果使用`struct`关键字，则定义在第一个访问说明符之前的成员是`publc`；相反，如果使用`class`关键字，则这些成员是`private`

### 友元

`Sales_data`的数据成员是`private`的，`read`、`print`和`add`函数就无法进行正常编译了，因为它们不是类的成员。

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。如果类想把一个函数作为它的友元，只需要增加一条以`friend`关键字开始的函数声明语句：


        class Sales_data{
        //为Sales_data的非成员函数所作的友元声明
        friend Sales_data add(const Sales_data&, const Sales_data&);
        friend std::istream &read(std::istream&, Sales_data&);
        friend std::ostream &print(std::ostream&, const Sales_data&);
        public:
            Sales_data() = default;
            Sales_data(const std::string &s, unsigned n, double p):
                bookNo(s), units_sold(n), revenue(p*n){}
            Sales_data(std::istream &);
            std::string isbn() const {return bookNo;}
            Sales_data &combine(const Sales_data&);
        private:
            double avg_price() const
                {return units_sold ? revenue/unit_sold:0;}
            std::string bookNo
            unsigned units_sold = 0;
            double revenue = 0.0;
    };
    Sales_data add(const Sales_data&, const Sales_data&);
    std::istream &read(std::istream&, Sales_data&);
    std::ostream &print(std::ostream&, const Sales_data&);

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员，也不受它所在区域访问控制级别的限制。

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，就必须要在友元声明之外再专门对函数进行一次声明。

通常将友元的声明与类本身放置在同一个头文件中（类的外部）。

## 类的其他特性

### 类型成员

    class Screen{
    public:
        typedef std::string::size_type pos;
    private:
        pos cursor = 0;
        pos height = 0, width = 0;
        std::string contents;
    };

`public`部分定义了`pos`，用户就可以使用这个名字。`Screen`的用户不应该知道`Screen`使用了一个`string`对象来存放数据，通过`pos`定义成`public`成员可以隐藏`Screen`实现的细节。

也可以使用类型别名

    class Screen{
    public:
        using pos = std::string::size_type;
    private:
        pos cursor = 0;
        pos height = 0, width = 0;
        std::string contents;
    };

用来定义类型的成员必须先定义后使用，与普通成员有所区别。因此类型成员通常定义在类开始的地方。

### 令成员作为内联函数

    class Screen{
    public:
        typedef std::string::size_type pos;
        Screen() = default;     //因为Screen有另一个构造函数，所以该函数是必须的
        //cursor被其类内初始值初始化为0
        Screen(pos ht, pos wd, char c):height(ht), width(wd),
            contents(ht*wd, c){}
        char get()const             //读取光标处的字符
        {return contents[cursor];}   //隐式内联
        inline char get(pos ht, pos wd)const;    //显示内联
        Screen &move(pos r, pos c);             //能在之后被设置为内联
    private:
        pos cursor = 0;
        pos height = 0, width = 0;
        std::string contents;
    };

可以在类的内部把`inline`作为声明的一部分显示地声明成员函数，同样的，也能在类的外部用`inline`关键字修饰函数的定义：

    inline 
    Screen &Screen::move(pos r, pos c)
    {
        pos row = r*width;          //计算行的位置
        cursor = row + c;           //行内移动光标到指定的列
        return *this;
    }
    char Screen::get (pos r, pos c)const
    {
        pos row = r * width;        //计算行的位置
        return contents[row+c];     //返回指定列的字符
    }

### 重载成员函数

类的成员函数也可以被重载，只要函数之间在参数的数量和/或类型上有所区别就行。

    Screen myscreen;
    char ch = myscreen.get();       //调用Screen::get()
    ch = myscreen.get(0,0);         //调用Screen::get(pos, pos)
    

### 可变数据成员


### 类数据成员的初始值