# 类

类的基本思想是数据抽象和封装。想要实现数据抽象和封装，需要先定义一个抽象数据类型。

当在调用成员函数时，其实是替某个对象调用它。成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。当调用一个成员函数时，用请求该函数的对象地址初始化`this`。

    total.isbn();

则编译器负责把`total`的地址传递给`isbn`的隐式形参`this`。

`this`形参是隐式的，任何自定义名为`this`的参数或者变量的行为都是非法的。可以在成员函数内部使用`this`。

## 定义Sales_data类


    struct Sales_data{
        std::string isbn() const {return bookNo;}
        Sale_data& combine(const Sales_data&);
        double avg_price() const;
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
    }

`isbn`函数的另一个关键之处是紧随参数列表之后的`const`关键字，这里，`const`的作用是修改隐式`this`指针的类型。

默认情况下，`this`的类型是指向类类型非常量版本的常量指针。例如在`Sales_data`成员函数中，`this`的类型是`Sales_data *const`。尽管`this`是隐式的，但是它仍然需要遵循初始化规则，意味着不能将`this`绑定到一个常量对象上。使得我们不能在一个常量对象上调用普通的成员函数。所以把`this`声明成`const Sales_data* const`，这样有助于提高函数的灵活性。

然而，`this`的声明是隐式的，C++的做法是允许把`const`关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的`const`表示`this`是一个指向常量的指针。这样使用`const`的成员函数被称做常量成员函数。

### 类的作用域和成员函数

成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。

#### 在类的外部定义成员函数

    double Sales_data::avg_price() const            //如果成员被声明为常量成员函数，需要指定const，且需要包含所属的类名
    {
        if(units_sold)
            return revenue/units_sold;
        else
            return 0;
    }

### 定义一个返回this对象的函数

    Sales_data& Sale_data::combine(const Sales_data &rhs)
    {
        units_sold += rhs.units_sold;               //把rhs的成员加到this对象的成员上
        revenue += rhs.revenue;
        return *this;                               //返回调用该函数的对象
    }

当调用函数时，

    total.combine(trans);                           //更新变量total当前的值

`return`语句解引用`this`指针以获得执行该函数的对象，换句话说，这个调用返回`total`的引用。   

## 构造函数

> 构造函数:初始化类对象的数据成员。

- 构造函数的名字与类名相同；
- 构造函数有一个可能为空的参数列表和一个可能为空的函数体；
- 构造函数没有返回类型；
- 类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有区别；
- 构造函数不可以被声明为const。

当创建类的一个`const`对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性，因此，构造函数在`const`对象的构造过程中可以向其写值。


如果类没有显示的定义构造函数，那么编译器就会隐式的定义一个默认构造函数，无须任何实参。

    struct Sales_data{
        Sales_data() = default;
        Sales_data(const std::string &s): bookNo(s){}
        Sales_data(const std::string &s, unsigned n, double p):
         bookNo(s), units_sold(n), revenue(p*n) {}
        Sales_data(std::istream &);
    }

`=defalut`表示是一个默认构造函数。定义这个构造函数的目的仅仅因为既需要其他形式的默认参数，也需要默认的构造函数。

`=default`既可以和声明一起出现在类的内部，也可以作为