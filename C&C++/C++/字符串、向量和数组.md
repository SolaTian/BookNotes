# 字符串、向量和数组

## 命名空间的using使用

作用域操作符`::`表示编译器从操作符左侧所示名字的作用域中寻找右侧那个名字。`std::cin`表示使用命名空间`std`中的名字`cin`

使用了`using`就表示无需要专门的前缀，也能使用所需要的名字。

    //using namespace::name

    #include <iostream>
    using std::cin;

    int main()
    {
        int i;
        cin >> i;       //cin和std::cin含义相同
        cout << i;      //错误，没有对应的using声明，必须使用完整的名字
        std::cout << i; //正确，显式从std中使用cout
        return 0;
    }

每个名字都需要独立的`using`声明。头文件中不应该包含`using`声明。防止被多个包含了该头文件的文件有这个声明。


## 标准库类型string

标准库类型`string`表示可变长的字符序列，需要先包含`string`头文件。作为标准库的一部分，`string`定义在命名空间`std`中

    #include <string>
    using std::string

### 定义和初始化对象

    string s1;              //默认初始化，s1是一个空字符串
    string s2(s1);          //s2是s1的副本
    string s2 = s1;         //s2是s1的副本
    string s3("hiya");      //s3是字面值的副本
    string s3 = "hiya";     //s3是该字符串字面值的副本
    string s4(10, 'c');     //s4的内容是cccccccccc

#### 直接初始化和拷贝初始化

使用等号初始化一个变量，实际上执行的是拷贝初始化，如果不使用等号，则执行的是直接初始化。

### string对象上的操作

#### 读写`string`对象

    int main()
    {
        string s;               //空字符串
        cin >> s;               //string对象读入s，遇到空白停止
        cout << s << endl;      //输出s
        return 0;   
    }

    int main()
    {
        string s1, s2;          
        cin >> s1 >> s2;            //把第一个输入读到s1中，第二个输入读到s2中
        cout << s1 << s2 << endl;   //输出两个string对象
        return 0;
    }

#### 读取未知的`string`对象

    int main()
    {
        string word;
        while(cin >> word)              //反复读取，直至文件末尾
        {
            cout << word << endl;       //逐个输出单词，每个单词后面紧跟一个换行
        }
         return 0;
    }

#### 使用`getline`读取一整行

    int main()
    {
        string line;
        //每次读入一整行，直至到达文件末尾
        while(getline(cin, line))           //触发getline()返回的换行符被丢弃，string对象中不包含该换行符
        {
            cout << line << endl;
        }
        return 0;
    }

#### `string`的`empty`和`size`操作

`empty`函数根据`string`对象是否为空返回一个对应的布尔值

    //每次读入一整行，遇到空行直接跳过
    while(getline(cin, line))
    {
        if(!line.empty())
        {
            cout << line << endl;
        }
    }

`size`函数返回`string`对象的长度

    //每次读入一整行，输出其中超过80个字符的行
    while(getline(cin, line))
    {
        if(line.size() > 80)
        {
            cout << line << endl;
        }
    }

#### 比较`string`对象
- 如果两个`string`对象在某些对应的位置不一样，则`string`对象比较的结果其实是`string`对象中第一相异字符的比较结果
- 如果两个`string`对象长度不同，且较短`string`对象的每个字符都与较长`string`对象对应位置上的字符相同，则较短的`string`对象小于较长`string`对象。

#### `string`对象的赋值

    string str1(10, 'c'), str2;             //str1的内容是cccccccccc;str2是一个空字符串
    str1 = str2;                            //赋值：用str2的副本替换str2的内容，str1和str2的空字符串

#### 两个string对象相加

    string s1 = "hello, ", s2 = "world\n";
    string s3 = s1 + s2;                        //s3的内容是hello, world\n
    s1 += s2;                                   //s1 = s1 + s2

#### 字面值和string对象相加

    string s1 = "hello", s2 = "world";
    string s3 = s1 + ", " + s2 + '\n';

当把`string`对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符`+`的两侧运算对象至少有一个`string`对象。

    string s4 = s1 + ", ";                  //正确
    string s5 = "hello" + ", ";             //错误
    string s6 = s1 + ", " + "world";        //正确，每个加法运算符都有一个运算对象是string，相当于string s6 = (s1 + ", ") + "world";
    string s7 = "hello" + ", " + s2;        //错误，不能把字面值直接相加

在C++中，字符串字面值与`string`是不同的类型。


### 处理string对象中的字符

#### 处理每个字符，使用基于范围的for语句

    string str("some string");
    //每行输出str中的一个字符
    for(auto c : str)                       //对于str中的每个字符
    {
        cout << c << endl;                  //输出当前字符，后面紧跟一个换行符
    }

    string s("Hello World!!!");
    decltype(s.size())punct_cnt = 0;
    for(auto c : s)
        if(ispunct(c))
            ++punct_cnt;                    //将标点符号的计数值加1
    count << punct_cnt
          << " punctuation characters in "<< s << endl;

输出的结果为`3 punctuation characters in Hello World!!!`

#### 使用范围for语句改变字符串中的字符

如果想要改变`string`对象中字符的值，必须把循环变量定义成引用类型。引用只是对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。

    string s("Hello World!!!");
    for(auto &c:s)                      //对于S中的每个字符（c是引用）
        c = toupper(c);                 //c是一个引用，因此赋值语句将改变s中字符的值
    cout << s << endl;

输出的结果为`HELLO WORLD!!!`

#### 只处理一部分字符

想要访问`string`对象中单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。

下标运算符`[]`接收的输入参数是`string::size_type`类型的值，这个参数表示要访问的字符的位置：返回值是该位置上字符的引用。

`string`对象的下标从0记起。`s[s.size()-1]`是最后一个字符。

    if(!s.empty())              //确保确实有字符需要输出
        cout << s[0] << endl;   //输出s的第一个字符

    string s("some string");
    if(!s.empty())              //确保s[0]的位置确实有字符
        s[0] = toupper(s[0]);   //为s的第一个字符赋一个新值


#### 使用下标执行迭代

    for (decltype(s.size())index = 0; index != s.size() && !isspace(s[index]); ++index)
        s[index] = toupper(s[index]);           //将当前字符改成大写

程序输出的结果为`SOME string`

下标必须大于等于0而小于字符串的`size()`值


#### 使用下标执行随机访问

    const string hexdigits = "0123456789ABCDEF";    //可能的十六进制数字
    cout << "Enter a series of numbers between 0 and 15"
        << " separated by spaces. Hit ENTER when finished: "
        << endl;
    string result;              //用于保存十六进制的字符串
    string::size_type n;        //用于保存从输入流读入的数
    while(cin>>n)
        if(n<hexdigits.size())  //忽略无效输入
            result += hexdigits[n]; //得到对应的十六进制数字
    
## 标准库类型vector

标准库类型`vector`表示对象的集合，其中所有的对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。

想要使用`vector`，必须包含适当的头文件。

    #include <vector>
    using std:: vector

`vector`是一个类模版，对于类模板来说，需要在模板名字后面跟一对尖括号，在括号内放上信息。

    vector<int> ivec;                   //ivec用于保存int类型的对象
    vector<Sales_item> Sales_vec;       //保存Sales_item类型的对象
    vector<vector<string>> file;        //该向量的元素是一个vector对象

`vector`是模板而非类型，由`vector`生成的类型必须包含`vector`中元素的类型，例如`vector<int>`

`vector`能容纳绝大多数类型的对象作为其元素，但是引用不能作为对象，不存在包含引用的`vector`。


### 定义和初始化vector对象

    vector<T> v1;           //v1是一个空vector，它潜在的元素是T类型的，执行默认初始化
    vector<T> v2(v1);       //v2是包含v1所有元素的副本
    vector<T> v2 = v1;      //等价于v2(v1)，v2中包含有v1所有元素的副本
    vector<T> v3(n, val);   //v3包含了n个重复的元素，每个元素的值都是val
    vector<T> v4(n);        //v4包含了n个重复地执行了值初始化的对象
    vector<T> v5{a,b,c...};  //v5包含了初始值个数的元素，每个元素被赋予了相应的初始值
    vector<T> v5={a,b,c...};    //等价于v5{a,b,c...}

#### 列表初始化vector对象

    vector<string> srt = {"a", "an", "the"};        //列表初始化

#### 创建指定数量的元素

    vector<int> ivec(10, -1);               //10个int类型的元素，每个都被初始化为-1
    vector<string> svec(10, "hi!");         //10个string类型的元素，每个都被初始化为"hi!"

#### 值初始化

通常可以只提供`vector`对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋值给容器中的所有的元素。这个初值由`vector`对象中元素的类型决定。

    vector<int> ivec(10);                   //10个元素，每个都被初始化为0
    vector<string> svec(10);                //10个元素，每个都是空string对象

但是有些类必须要求明确提供初始值，因为这些类型不支持默认初始化。

#### 列表初始化和元素数量

    vector<int> v1(10);         //v1有10个元素，每个值都是0
    vector<int> v2{10};         //v2有1个元素，该元素的值是10
    vector<int> v3(10, 1);      //v3有10个元素，每个的值都是1
    vector<int> v4{10, 1};      //v4有2个元素，值分别是10和1

    vector<string> v5{"hi"};        //列表初始化：v5有一个元素
    vector<string> v6("hi");        //错误：不能使用字符串字面值构建vector对象
    vector<string> v7{10};          //v7有10个默认初始化的元素
    vector<string> v8{10, "hi"};    //v8有10个值为"hi"的元素

### 向vector对象中添加元素

前面的初始化适用于初始值已知数量较少，或者初始值是另一个`vector`对象的副本，所有的元素的初始值都一样。

`push_back`负责将一个值当成`vector`对象的尾元素压入到`vector`对象的尾端。

    vector<int> v2;             //空vector对象
    for(int i=0; i!=100; ++i)
        v2.push_back(i);        //依次把整数值放到v2尾端

    string word;
    vector<string> text;
    while(cin >> word)
    {
        text.push_back(word);       //把word添加到text后面
    }

### 其他vector操作

除了`push_back`，还有一些其他重要操作

    v.empty();          //如果v不含有任何元素，返回真；否则返回假
    v.size();           //返回v中元素的个数
    v.push_back(t);     //向v的尾端添加一个值为t的元素
    v[n];               //返回v中第n个位置上元素的引用
    v1 = v2;            //用v2中元素的拷贝替换v1中的元素
    v1 = {a,b,c...};    //用列表中元素的拷贝替换v1中的元素
    v1 == v2;           //v1和v2相等当且仅当它们的元素数量相同对应位置的元素值都相同
    v1 != v2;

访问`vector`对象中元素的方法和访问`string`对象中的字符方法差不多，也是通过元素在`vector`对象中的位置。

    vector<int> v{1,2,3,4,5,6,7,8,9};
    for(auto &i : v)                    //对v中的每个元素(i是一个引用)
        i*=i;                           //求元素值的平方
    for(auto i : v)                     //对于v中的每个元素
        cout << i << " "                //输出该元素
        cout << endl;             

由于使用的是引用，可以通过`i`给`v`的元素赋值。

`vector`的`size`返回`vector`对象中元素的个数，返回值的类型是由`vector`定义的`size_type`类型。要使用`size_type`，需要先指定它是由哪种类型定义的。

    vector<int>::size_type          //正确
    vector::size_type               //错误

#### 计算vector内对象的索引

    vector<unsigned> scores(11, 0);         //11个分数段，全部初始化为0
    unsigned grade;                         
    while(cin >> grade)                     //读取成绩
    {
        if(grade <= 100)                    //只处理有效的成绩
            ++scores[grade/10];             //将对应分数段的计数值加1
    }

`++scores[grade/10];`等价于`auto ind = grade/10;`和`scores[ind] = scores[ind] + 1;`

#### 不能使用下标形式添加元素

`vector`对象以及`string`对象的下标运算符可以用于访问已存在的元素，而不能用于添加元素。只能对已经存在的元素执行下标操作。

## 迭代器

除了`vector`之外，标准库还定义了其他几种容器。所有的标准库容器都可以使用迭代器，但是只有少数几种才同时支持下标运算符。`string`对象不属于容器类型，但是`string`支持很多与容器类型相似的操作。`vector`支持下标运算符，这一点和`string`一样，`string`支持迭代器，和`vector`一样。

### 使用迭代器

    //b表示v的第一个元素，e表示v尾元素的下一位置
    auto b = v.begin(), e = v.end();        //b和e的类型相同

`end`成员负责返回指向容器（或`string`对象）尾元素的下一位置的迭代器。该迭代器指示的是一个本不存在的“尾后”元素。`end`迭代器被称为尾后迭代器。特殊情况下如果容器为空，`begin`和`end`返回的是同一个迭代器。都是尾后迭代器。

#### 迭代器运算符

    *iter                   //返回迭代器iter所指元素的引用
    iter->mem               //解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
    ++iter                  //令iter指向容器的下一个元素
    --iter                  //令iter指向容器的上一个元素
    iter1 == iter2          //判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者他们是同一个容器的尾后迭代器，则相等；反之不相等。

    //将string对象的第一个字母改成大写形式，使用迭代器
    string s("some string");
    if(s.begin() != s.end())            //确保s非空
    {
        auto it = s.begin();            //it表示s的第一个字符
        *it = toupper(*it);             //将当前字符改成大写形式
    }

#### 将迭代器从一个元素移动到另一个元素

    //依次处理s的字符直至我们处理完全部字符或者遇到空白
    for(auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
        *it = toupper(*it);             //将字符改写成大写形式

#### 迭代器类型

就像不知道`string`和`vector`的`size_type`成员到底是什么类型一样，一般来说也不知道也无需知道迭代器的类型。实际上可以使用`iterator`和`const_iterator`来表示迭代器的类型

    vector<int>::iterator it;       //it能读写vector<int>的元素
    string::iterator it2;           //it2能读写string对象中的字符

    vector<int>::const_iterator it3;    //it3只能读写元素，不能写元素
    string::const_iterator it4;         //it4只能读字符，不能写字符

#### begin和end运算符

`begin`和`end`返回的具体类型由对象是否为常量决定，如果对象是常量，`begin`和`end`返回`const_iterator`，如果对象不是常量，返回`iterator`

    vector<int> v;
    const vector<int> cv;
    auto it1 = v.begin();           //it1的类型是vector<int>::iterator
    auto it2 = cv.begin();          //it2的类型是vector<int>::const_iterator

    auto it3 = v.cbegin();          //it3的类型是vector<int>::const_iterator

#### 结合解引用和成员访问操作

解引用迭代器可以获得迭代器所指的对象。
    
    (*it).empty();                  //解引用it，然后调用结果对象的empty()成员
    *it.empty();                    //错误，试图访问it的名为empty()的成员，但是it是一个迭代器，
                                    //没有empty成员

为了简化上述表达式，采用箭头运算符`->`，把解引用和成员访问两个操作结合在一起。`it->mem`和`(*it).mem`表达的意思相同。

    for(auto it = text.cbegin();
        it != text.cend() && !it->empty(); ++it)
        cout << *it << endl;


## 数组

数组类似于标准库类型`vector`，与`vector`不同的地方在与：数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定。不清楚元素的确切个数，请使用`vector`。

### 定义和初始化内置数组

定义数组的时候必须指定数组的类型，不允许用`auto`关键字由初始值的列表推断类型。和`vector`一样，数组的元素应为对象，因此不存在引用的数组。

    int &res[10] = /*?*/;           //不存在引用的数组

#### 不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。

    int a[] = {0,1,2};              //含有3个整数的数组
    int a2[] = a;                   //错误：不允许使用一个数组初始化另一个数组
    a2 = a;                         //错误

#### 复杂的数组声明

    int *ptr[10];                   //ptr是含有10个整型指针的数组
    int (*Parray)[10] = &arr;       //Parray指向一个含有10个整数的数组
    int (&arrRef)[10] = arr;        //arrRef引用一个含有10个整数的数组

### 访问数组元素

数组除了大小固定之外，其他用法和`vector`基本类似。

    unsigned scores[11] = {};
    unsigned grade;
    while (cin >> grade)
    {
        if(grade <= 100)
            ++score[grade/10];          //将当前分数段计数值加1
    }

    for(auto i : scores)                //对scores中的每个计数值
        cout << i << " ";               //输出当前的计数值
    cout << endl;

### 指针和数组

数组有个特性，在很多用到数组名字的地方，编译器都会自动将其替换为一个指向数组首元素的指针。

    string nums[] = {"one", "two", "three"};
    string *p2 = nums;      //等价于p2 = &nums[0];
    
数组作为一个`auto`变量的初始值时，推断得到的类型是指针而非数组。

    int ia[] = {0,1,2,3,4,5};   
    auto ia2(ia);           //ia2是一个整型指针，指向ia的第一个元素
    ia2 = 42;               //错误，ia2是一个整型指针，不能用int值给指针赋值

其中的`auto ia2(ia);`相当于`auto ia2(&ia[0]);`当使用`decltype`关键字时，上述转换不会发生，`decltype(ia)`返回的类型是由10个整数构成的数组。

#### 指针也是迭代器

`vector`和`string`的迭代器支持的运算，数组的指针全部支持。

    int arr[] = {0,1,2,3,4,5,6,7,8,9};
    int *p = arr;                   //p指向arr的第一个元素
    ++p;                            //p指向arr[1]

    int *e = &arr[10];              //指向arr尾元素的下一位置的指针

    //利用不存在的元素，用于初始化
    for(int *b = arr; b != e; ++b)
        cout << *b << endl;         //输出arr的元素

#### 标准库函数begin和end

    int ia[] = {0,1,2,3,4,5,6,7,8,9};
    int *beg = begin(ia);                   //指向ia首元素的指针
    int *last = end(ia);                    //指向ia尾元素的下一位置的指针


一个指针如果指向了某种内置数据类型数组的尾元素的下一位置，则其具备与`vector`的`end`函数返回的与迭代器类似的功能。尾后指针不能进行解引用和递增操作。

#### 解引用和指针运算的交互

    int ia[] = {0,1,2,3,4};
    int last = *(ia+4);         //将last初始化为8，ia[4]的值

    last = *ia + 4;             //last=4，将ia[0]+4赋值给last

### C风格字符串

C风格字符串不是一种类型。这种类型的字符串存放在字符数组中并以空字符结束。以空字符结束的意思是在最后一个字符后面跟着一个空字符`\0`，一般利用指针来操作C风格字符串。

#### C标准库String函数

定义在`cstring.h`头文件中。

    strlen(p);                      //返回p的长度
    strcmp(p1, p2);                 //比较p1和p2的大小，相等返回0
    strcat(p1, p2);                 //将p2附加到p1之后，返回p1
    strcpy(p1, p2);                 //将p2拷贝给p1，返回p1

#### 比较字符串

在C++中比较标准库`string`对象的时候，用的是普通的关系运算符

    string s1 = "A string example";
    string s2 = "A different string";
    if(s1<s2)               //正确

    const char ca1[] = "A string example";
    const char ca2[] = "A different string";
    if(ca1<ca2)             //错误，试图比较两个地址

#### 字符串拼接
使用`string`对象，拼接字符串

    string largeStr = s1 + " " + s2;

使用C风格字符串在拼接时就需要使用`strcpy`和`strcat`函数，必须要提供一个存放结果字符串的足够大的数组

    strcpy(largeStr, ca1);
    strcat(largeStr, " ");
    strcpy(largeStr, ca2);

不用考虑C风格字符串在拼接的时候，目标数组空间不够的情况。


### 与旧代码的接口

#### 混用string对象和C风格字符串

    string s("Hello World");    //s的内容是Hello World
    char *str = s;              //错误：不能用string对象初始化char *
    const char *str = s.c_str();    //正确

`c_str()`函数的返回值为一个C风格的字符串。函数的返回值为一个指针，指向一个以空字符结束的字符数组，结果指针的类型为`const char*`

#### 使用数组初始化vector对象

允许使用数组来初始化`vector`对象

    int int_arr[] = {0,1,2,3,4,5};
    //iVec有6个元素，分别是int_arr中对应元素的副本
    vector<int> iVec(begin(int_arr), end(int_arr));

`begin`和`end`分别计算`int_arr`的首指针和尾后指针。最终的结果中`iVec`中将包含6个元素，次序和值都与数组`int_arr`完全一样。

用于初始化`vector`对象的值也可能仅是数组的一部分

    vector<int> subVec(int_arr+1, int_arr+4);

## 多维数组

### 多维数组的初始化

    int ia[3][4] = {
        {0,1,2,3},
        {4,5,6,7},
        {8,9,10,11}
    };

    int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
    int ia[3][4] = {{0}, {4}, {8}};             //显示初始化每行的首元素
    int ia[3][4] = {0, 3, 6, 9};                //显示初始化第一行，其他行初始化为0

### 多维数组的下标引用

如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组。

### 使用范围for语句处理多维数组

    size_t cnt = 0;
    for (auto &row : ia)            //对外层数组的每一个元素
        for(auto &col : row)        //对内层数组的每一个元素
        {
            col = cnt;              //将下一个值赋值给该元素
            ++cnt;                  //cnt加1
        }

第一个`for`循环遍历`ia`的所有元素，这些元素是大小为4的数组，第二个`for`循环遍历4元素数组中的某一个，因此`col`的类型是整数的引用。每次迭代把`cnt`的值赋给`ia`的当前元素，然后将`cnt`加1。

在上面的例子中，因为要改变数组元素的值，所以选用引用类型作为循环控制变量。即使没有任何写操作，还是需要将外层循环的控制变量声明成引用类型。

    for (auto row : ia)
        for(auto col : row)

这样在编译的时候会报错，因为第一个循环遍历，`row`没有使用引用类型，所以编译器初始化`row`时会自动将这些数组形式的元素转换成指向该数组的首元素的指针。`row`的类型就成了`int *`，这样的内层循环就不合法了。

使用范围`for`处理多维数组，除了最内存的循环外，其他的所有循环的控制变量都应该是引用类型。


### 指针和多维数组

    int ia[3][4];
    int (*p)[4] = ia;       //p指向含有4个整数的数组
    p = &ia[2];             //p指向ia的尾元素


使用`auto`或者`decltype`尽可能避免再数组前面加上一个指针类型

    //输出ia中每个元素的值，每个内层数组占一行
    //p指向含有4个整数的数组
    for(auto p = ia; p != ia + 3; ++p)
    {
        //q指向4个整数数组的首元素，q指向一个整数
        for(auto q = *p; q != *p + 4; ++q)
            cout << *q << ' ';
        cout << endl;
    }
        

使用标准库`begin`和`end`也能实现同样的功能

    //p指向ia的第一个数组
    for(auto p = begin(ia); p != end(ia); ++p)
    {
        //q指向内层数组的首元素
        for(auto q = *p; q != *p + 4; ++q)
            cout << *q << ' ';
        cout << endl;
    }
        

### 类型别名简化为多维数组的指针

    using int_array *p = int[4];        //新标准下类型别名的声明
    typedef int int_array[4];           //等价的typedef声明

    //输出ia中每个元素的值，每个内层数组各占一行
    for(int_array *p = ia; p != ia + 3; ++p)
    {
        for(int *q = *p; q != *p + 4; ++q)
            cout << *q << ' ';
        cout << endl;
    }

