# 表达式

大部分表达式和C语言中用法一致。

## 关系运算符

关系运算符都满足左结合律

    if(i<j<k)           //使用i<j的布尔值和k比较
    if(i<j && j<k)      //正确的写法

## 赋值运算符

赋值运算符满足右结合律

    int ival, jval;
    ival = jval = 0;        //正确，都被赋值为0

赋值运算符满足右结合律，所以右侧的`jval = 0`作为靠左的赋值运算符的右侧运算对象。又因为赋值运算符返回的是其左侧运算对象，所以靠右的赋值运算的结果被赋值给了`ival`。

    string s1, s2;
    s1 = s2 = "OK";         //字符串字面值"OK"转换成string对象

赋值运算符的优先级低于关系运算符，所以在条件语句中，赋值部分需要加上括号。

## 递增、递减运算符

递增和递减运算符有两种形式：前置版本和后置版本。
- 前置版本，首先将运算对象加1或减1，然后将改变后的对象作为求值结果。
- 后置版本，也会将运算对象加1或减1，但是求值结果是运算对象改变之前的那个副本

    int i = 0, j;
    j = ++i;            //j=1,i=1:前置版本得到递增之后的值
    j = i++;            //j=1,i=2:后置版本得到递增之前的值

除非必须，否则不使用后置版本。

### 在一条语句中混用解引用和递增运算符

    auto pbeg = v.begin();
    //输出元素直至遇到第一个负值为止
    while(pbeg != v.end() && *pbeg >= 0)
        cout << *pbeg++ << endl;            //输出当前值并将pbeg向前移动一个元素
    
**后置运算符的的优先级高于解引用运算符**。因此`*pbeg++`等价于`*(pbeg++)`，`pbeg++`把`pbeg`的值加1，然后返回`pbeg`的初始值的副本作为其求值结果，所以这条语句输出`pbeg`最开始指向的那个元素，并将指针向前移动一个位置。

    for(auto it = s.begin(); it != s.end(); && !isspace(*it); ++it)
        *it = toupper(*it);                     //将当前字符改成大写形式

下面这个循环就是未定义的

    while(beg != s.end() && !isspace(*beg))
        *beg = toupper(*beg++);                 //错误，右侧改变了beg的值

## 成员访问运算符

`pstr->mem`等价于`(*ptr).mem`

**解引用运算符的优先级低于点运算符**，因此执行解引用运算的子表达式两端必须加上括号。

    string s1 = "a string", *p = &s1;
    *p = size();                            //错误：p是一个指针，它没有名为size的成员

## 条件运算符

嵌套条件运算符

    finalgrade = (grade > 90)?"high pass":(grade < 60)?"fail":"pass";

条件运算符满足右结合律，意味着运算对象一般按照从右到左的顺序组合。因此，靠右的条件运算符（比较成绩是否小于60）构成了左边的条件运算`:`分支。

## 位操作符

### 移位运算符

左侧的运算对象按照右侧运算对象的要求移动指定位数。然后将经过移动的左侧运算对象的拷贝作为求值结果。

- 左移运算符:`<<`在右侧插入值为0的二进制位。
- 右移运算符：`>>`的行为依赖于左侧运算对象的类型，如果是无符号类型，则在左侧插入值为0的二进制序列，如果是带符号类型，则在左侧插入符号位的副本或者0的二进制位，具体视环境而定。

### 移位运算符（IO运算符）满足左结合律

移位运算符满足左结合律

    cout << "hi" << " there " << endl;

相当于

    ((cout << "hi") << " there ") << endl;

移位运算符的优先级：比算数运算符的优先级低，但是比关系运算符、赋值运算符和条件运算符的优先级高。

    cout << 42 + 10;            //正确
    cout << (10 < 42);          //正确
    cout << 10 < 42;            //错误

## sizeof运算符

`sizeof`运算符返回一个表达式或者一个类型名字所占的字节数。

    Sales_data data, *p;
    sizeof(Sales_data);                 //存储Sales_data类型的对象所占的空间大小
    sizeof data;                        //data的类型大小，即sizeof(Sales_data)
    sizeof p;                           //指针所占的空间大小
    sizeof *p;                          //p所指的空间的大小，即sizeof(Sales_data)
    sizeof data.revenue;                //Sales_data的revenue成员对应的大小
    sizeof Sales_data::revenue;         //另一种获取revenue大小的方式

`sizeof`满足右结合律并且与`*`运算符的优先级一样，`sizeof *p`等价于`sizeof (*p)`，即使`p`是一个未初始化的指针，也不会有影响。在`sizeof`的运算对象中解引用一个无效指针仍然是一种安全行为。

`sizeof`运算符的结果部分依赖于其作用的类型：
- 对`char`或者类型为`char`的表达式执行`sizeof`，结果为1
- 对引用类型执行`sizeof`运算得到的被引用对象所占空间的大小
- 对指针执行`sizeof`运算得到指针本身所占的空间的大小
- 对解引用指针执行`sizeof`运算得到指针指向的对象所占空间的大小，指针不需要有效。
- 对数组执行`sizeof`运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次`sizeof`运算并将所得结果相加，`sizeof`不会将数组转成指针来处理。
- 对`string`对象或者`vector`对象执行`sizeof`运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。
  

可以使用数组的大小除以单个元素的大小得到数组中元素的个数

    constexpr size_t sz = sizeof(ia)/sizeof(*ia);
    int arr2[sz];

## 逗号运算符

逗号运算符含有两个运算对象，按照从左到右的顺序依次求值。首先对左侧表达式求值，然后将求值结果丢弃。真正的运算结果为右侧表达式的值。

    vector<int>::size_type cnt = ivec.size();
    //将把从size到1的值赋值给ivec的元素
    for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
        ivec[ix] = cnt;

循环中递增`ix`，递减`cnt`，每次循环迭代`ix`和`cnt`相应改变，只要`ix`满足条件，就把当前元素设成`cnt`当前的值。

    