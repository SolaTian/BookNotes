# 函数

## 函数基础——局部对象

> 自动对象：只存在于块执行期间的对象称为自动对象。

当块的执行结束时，块中创建的自动对象的值就变成未定义的了。函数的形参就是一种自动对象。

> 局部静态对象：在程序第一次经过对象定义语句时初始化，并且直到程序终止才会被销毁，在此期间及时对象所在的函数执行结束也不会对其有影响。

将局部变量定义成为`static`类型而获得这样的对象。


## 参数传递

### 传值参数

指针形参，指针的行为和其他非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针可以间接访问指向的对象，所以通过指针可以修改它所指对象的值。

在C语言中，经常使用指针类型的形参访问函数外部的对象。在C++中，建议使用引用类型的形参代替指针。

### 传引用参数

    void reset(int &i)
    {
        i = 0;
    }

    int j = 42;
    reset(j);                       //j采用传引用方式，它的值被改变
    cout << "j = " << j << endl;

当调用`reset()`函数时，`i`绑定的是传给参数的`int`对象，改变`i`的值就是改变`i`所引对象的值。

使用引用时避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。

    //比较两个string对象的长度
    bool isShorter(const string &s1, const string &s2)
    {
        return s1.size() < s2.size();
    }

当函数无需修改引用形参的值时最好使用常量引用。


### 数组形参

尽管不能以值传递的方式传递数组，但是可以把形参写成类似于数组的形式：

    void print(const int*);
    void print(const int[]);
    void print(const int[10]);

上面3个函数是等价的，每个函数的唯一形参都是`const int *`

    int i = 9, j[2] = {0,1};
    print(&i);      //正确
    print(j);       //正确

管理指针形参有三种常用方法

#### 使用标记指定数组长度

要求数组本身包含一个结束标记，例如C风格字符串存储在字符数组中。

    void print(const char *cp)
    {
        if(cp)                          //若cp非空指针
        {
            while(*cp)                  //只要指针所指的字符不是空字符
                cout << *cp++;          //输出当前字符并将指针向前移动一个位置
        }
    }

#### 使用标准库规范

    void print(const int *beg, const int *end)
    {
        //输出beg到end之间的所有元素
        while(beg != end)
        {
            cout << *beg++ << endl;     //输出当前元素并将指针向前移动一个位置
        }
    }

    int j[2] = {0,1};
    print(begin(j), end(j));            //begin和end函数

#### 显示传递一个表示数组大小的形参

    void print(const int ia[], size_t size)
    {
        for(size_t i = 0; i != size; ++i)
        {
            cout << ia[i] << endl;
        }
    }

    int j[] = {0,1};
    print(j, end(j) - begin(i));

#### 数组引用形参

    void print(int (&arr)[10])
    {
        for(auto elem : arr)
            cout << elem << endl;
    }

`arr`是具有10个整数的整型数组的引用。

    int i =0, j[2] = {0, 1};
    int k[10] = {0,1,2,3,4,5,6,7,8,9};
    print(&i);                  //错误：实参不是含有10个整数的数组
    print(j);                   //错误：实参不是含有10个整数的数组
    print(k);                   //正确，实参是含有10个整数的数组

#### 传递多维数组

    //指向含有10个整数的数组的指针
    void print(int (*matrix)[10], int rowSize)

    //等价定义
    void print(int matrix[][10], int rowSize)

### main:处理命令行选项

有时需要给`main`函数传递实参，假设`main`函数位于可执行文件`prog`之内，可以通过向程序传递下面的选项

    prog -d -o ofile data0
这些命令行选项可以通过两个可选的形参传递给`main`函数

    int main(int argc, char *argv[])
    //或者
    int main(int argc, char **argv)

`argv`的第一个元素指向程序的名字或者一个空字符串，接下来的元素一次传递命令行提供的实参。最后一个指针之后的元素保证为0。
根据上面提供的命令行，`argc`应该等于5，`argv`应该包含以下C风格字符串

    argv[0] = "prog";        //或者argv[0]也可指向一个空字符串
    argv[1] = "-d";
    argv[2] = "-o";
    argv[3] = "ofile";
    argv[5] = 0;

当使用`argv`中的实参时，一定要记得可选的实参从`argv[1]`开始;`argv[0]`保存程序的名字，而非用户输入。

### 含有可变形参的函数

为了编写处理不同数量实参的函数，C++提供了两种方法
1. 如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型
2. 如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模版

`initializer_list`类型定义在同名的头文件中

    initializer_list<T> lst;                //默认初始化：T类型元素的空列表
    initializer_list<T> lst{a,b,c...};      //lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const
    lst2(lst);                              //拷贝或者赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后lst2 = lst，原始列表和副本共享元素
    lst.size();                             //列表中的元素数量
    lst.begin();                            //返回指向lst首元素的指针
    lst.end();                              //返回指向lst中尾元素下一位置的指针

`initializer_list`和`vector`一样，也是一种模版类型，定义`initializer_list`时，必须要说明列表中所含元素的类型，和`vector`不一样的是，`initializer_list`对象中的元素永远是常量值。

    initializer_list<string> ls;        //initializer的元素类型是string
    initializer_list<int> li;           //initializer的元素类型是int

    void error_msg(initializer_list<string> il)
    {
        for (auto beg = il.begin(); beg != il.end(); ++beg)
        {
            cout << *beg << " ";
        }
        cout << endl; 
    }

如果想向`initializer_list`形参中传递一个值的序列，必须把序列放在一对花括号中：

    //expected和actual是string对象
    if()
        error_msg({"functionX", expected, actual});
    else
        error_msg({"functionX", "Okay"});

#### 省略符形参

省略符形参只能出现在形参列表的最后一个位置

    void foo(parm_list, ...);
    void foo(...);

## 返回类型和return语句

### 有返回值函数

#### 不要尝试返回局部对象的引用或者指针

函数完成后，其所占用的存储空间也将被释放，其中局部变量的引用和指针不再指向有效的内存区域

#### 列表初始化返回值

C++11新标准规定，函数可以返回花括号包围的值的列表。列表也可以用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。

    vector<string> process()
    {
        //...
        //expected和actual是string对象
        if(expected.empty())
            return {};                      //返回一个空的vector对象
        else if(expected == actual)
            return {"functionX", "okay"};   //返回列表初始化的vector对象
        else    
            return {"functionX", expected, actual};
    }

### 返回数组指针

因为数组不能被拷贝，所以函数不能返回数组。

    typedef int arrT[10];               //arrT是一个类型别名，表示的类型是含有10个整数的数组
    using arrT = int[10];               //arrT的等价声明
    arrT *func(int i);                  //func返回一个指向含有10个整数的数组的指针

#### 声明一个返回数组指针的函数

    int arr[10];                        //arr是一个含有10个整数的数组
    int *p1[10];                        //p1是一个含有10个指针的数组
    int (*p2)[10] = &arr;               //p2是一个指针，指向含有10个整数的数组的指针

如果想要定义一个返回数组指针的函数，则数组的维度必须跟在函数的名字之后

    int (*func(int i))[10];

从里到外进行解释

    func(int i)             //表示调用func函数时需要一个int类型的实参
    (*func(int i))          //表示可以对函数调用的结果执行解引用操作
    (*func(int i))[10]      //表示解引用func的调用将得到一个大小为10的数组
    int (*func(int i))[10]  //表示数组中的元素是int类型

#### 使用尾置返回类型

使用尾置返回类型，对于返回比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型就在形参列表后面跟一个->开头。为了表示函数真正的返回类型跟在形参列表之后，在原本应该出现返回类型的地方放置一个`auto`。

    auto func(int i) -> int (*)[10];

#### 使用decltype

如果知道函数返回的指针将要指向哪个数组，就可以使用`decltype`关键字声明返回类型

    int odd[] = {1,3,5,7,9};
    int even[]= {0,2,4,6,8};

    decltype(odd) * arrPtr(int i)
    {
        return (i % 2)? &odd : &even;            //返回一个指向数组的指针。
    }

`decltype`并不负责将数组类型转换成为对应的指针，所以`decltype`的结果是一个数组，要想表示`arrPtr`返回指针必须在函数声明之前加一个`*`符号。


## 函数重载

如果同一个作用域内的几个函数名字相同但是形参列表不同，称之为重载函数。

之前章节定义的几个名为`print`的函数：

    void print(const char *cp);
    void print(const int *beg, const int *end);
    void print(const int ia[], size_t size);

这些函数接收的形参类型不一样，但是执行的操作非常类似。当调用这些函数的时候，编译器会根据传递的实参类型推断想要的是哪个函数。

函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员的起名字、记名字的负担。

`main`函数不能重载。


    Record lookup(const Account&);      //根据Account查找记录，省略了形参的名字
    Record lookup(const Phone&);        //根据Phone查找记录
    Record lookup(const Name&);         //根据Name查找记录
    Account acct;
    Phone phone;                
    Record r1 = lookup(acct);
    Record r2 = lookup(phone);      

不允许两个函数除了返回类型外其他所有的要素都相同。假设有两个参数，它们的形参列表一样，但是返回类型不一样，则第二个函数的声明是错误的。

### 重载和const形参

顶层`const`不影响传入函数的对象。一个拥有顶层`const`的形参无法和另一个没有顶层`const`的形参区分开来：

    Record lookup(Phone);
    Record lookup(const Phone);         //重复声明了Record lookup(Phone)

    Record lookup(Phone *);
    Record lookup(Phone *const);        //重复声明了Record lookup(Phone*)

如果形参是某种类型的指针或者引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的`const`是底层的

    Record lookup(Account&);           //函数作用与Account的引用
    Record lookup(const Account);      //新函数，作用与常量引用
    Record lookup(Account *);          //新函数，作用与指向Account的指针
    Record lookup(const Account*);     //新函数，作用与指向常量的指针

因为`const`形参不能转换成其他类型，所以只能把`const`对象（或者指向`const`的指针）传递给`const`形参。相反的，因为非常量可以转换成`const`，所以上面的4个函数都能作用与非常量对象或者指向非常量对象的指针。不过编译器会优先选择非常量版本的函数。 


### 调用重载的函数

函数调用与一组重载函数中某一个关联起来，叫做函数匹配，也叫做重载确定。

调用重载函数，有3中可能的结果：
1. 最佳匹配
2. 无匹配（报错）
3. 二义性调用（报错）

### 重载与作用域

在不同的作用域中无法重载函数名，内层作用域中声明的名字，将会隐藏外层作用域中的同名实体：

    string read();
    void print(const string &);
    void print(const double);           //重载
    void fooBar(int iVal)
    {
        bool read = false;
        string a = read();              //错误
        void print(int);
        print("Value ");                //错误
        print(iVal);                    //正确
        print(3.14);                    //错误         
    }

## 特殊用途语言特性

### 默认实参

某些函数有一种形参，在函数的多次调用中，它们都被赋予一个相同的值，将这个反复出现的值称为函数的默认实参。调用含有默认实参的函数，可以包含该实参，也可以省略该实参。

    typedef string :: size_type sz;
    string screen(sz ht = 24, sz wid = 80, char backgrnd = '');

默认实参作为形参的初始值出现在形参列表中，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

想要使用默认实参，只要在调用函数的时候省略该实参就可以了。

    string window;
    window = screen();                  //等价于screen(24, 80, '')
    window = screen(66);                //等价于screen(66, 80, '')
    window = screen(66, 256);           //screen(66, 256, '')
    window = screen(66, 256, '#');      //screen(66, 256, '#')

#### 默认实参声明

在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参都必须要有默认值。

    string screen(sz, sz, char='');
    string screen(sz, sz, char='*');            //错误：重复声明
    string screen(sz=24, sz=80, char);          //正确：添加默认实参

#### 默认实参初始值

局部变量不能作为默认实参。

    sz wd = 80;
    char def = ' ' ;
    sz ht();
    string screen(sz=ht(), sz=wd, char=def);
    string window = screen();               //调用screen(ht(),80,' ')
    void f2()
    {
        def = '*';                          //改变默认实参的值  
        sz wd = 100;                        //隐藏了外层定义的wd，但没有改变默认值
        window = screen();                  //调用screen(ht(),80,' ')
    }

### 内联函数和constexpr函数

函数调用上，调用前需要保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。

内联函数可以在函数的调用点上直接展开，避免函数调用的开销。

#### constexpr函数

`constexpr`函数指能用于常量表达式的函数。

定义`constexpr`函数要遵循：
1. 函数的返回类型及所有形参的类型都得是字面值类型。
2. 函数体中必须有且仅有一条return语句

    constexpr int new_sz() = {return 42;}
    constexpr int foo = new_sz();

在执行上述初始化时，编译器把`constexpr`函数的调用替换成结果值。为了能够在编译过程中随时展开，`constexpr`函数被隐式的指定为内联函数。

`constexpr`函数体内可以包含其他语句，只要这些语句在运行时不执行任何其他的操作就可以。例如，`constexpr`函数中可以有空语句，类型别名以及`using`声明。

允许`constexpr`函数的返回值并非一个常量：

    //如果arg是常量表达式，则scale(arg)也是常量表达式
    constexpr size_t scale(size_t cnt){return new_sz()*cnt;}

    int arr[scale(2)];          //正确，scale(2)是常量表达式
    int i = 2;                  //i不是常量表达式
    int a2[scale(i)];           //错误：scale(i)不是常量表达式

#### 把内联函数和constexpr函数放在头文件内

和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。对于某个给定的内联函数或者`constexpr`函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和`constexpr`函数通常定义在头文件中。

### 调试帮助

在C++中，有选择的执行调试代码。用到两项预处理功能：`assert`和`NDEBUG`

#### assert

`assert`是一种预处理宏。所谓预处理宏就是一个预处理变量，它的行为类似于内联函数。

    assert(expr);

首先对`expr`函数求值，如果表达式为假，`assert`输出信息并终止程序的执行。如果表达式为真，`assert`什么也不做。`assert`定义在`cassert`头文件中。

#### NDEBUG

`assert`的行为依赖于一个名为`NDEBUG`的预处理变量的状态。如果定义了`NDEBUG`，则`assert`什么也不做。默认状态下没有定义`NDEBUG`，此时`assert`将执行运行时检查。

可以使用一个`#define`语句定义`NDEBUG`，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项可以定义预处理变量。

    $ CC -D NDEBUG main.c # use /D with the Microsoft complier

这条命令的作用等价于在main.c文件的一开始写`#define NDEBUG`

`NDEBUG`还可以用于编写自己的调试代码。如果`NDEBUG`未定义，将执行`#ifdef`和`#endif`之间的代码。

    void print(const int ia[], size_t size)
    {
        #ifndef NDEBUG
            cerr << "Error: "<<_ _FILE_ _
                << " : in function " << _ _func_ _
                << " at line "<< "_ _LINE_ _ " << endl
                << "  Compiled on " << _ _DATE_ _
                << " at " << _ _TIME_ _ << endl
                << "  Word read was \"" << word
                << "\": Length too short" << endl;
        #endif 
    }

- _ _FILE_ _:存放文件名的字符串字面值
- _ _func_ _:存放函数名的字符串字面值
- _ _LINE_ _:存放当前行号的整型字面值
- _ _TIME_ _:存放文件编译时间的字符串字面值
- _ _DATE_ _:存放文件编译日期的字符串字面值


## 函数匹配

    void f();
    void f(int);
    void f(int, int);
    void f(double, double = 3.14);
    f(5.6);

函数匹配的步骤：
1. 选定本次调用对应的重载函数集，集合中的函数称为候选函数。
    
    候选函数的两个特征
   1. 与被调用的函数同名
   2. 其声明在调用点可见
2. 考察本次调用提供的实参，然后从候选函数中选出被这组实参调用的函数，新选出来的函数称为可行函数。

    可行函数的两个特征
    1. 形参数量与本次调用提供的实参数量相等
    2. 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型
3. 从可行函数中选择与本次调用最匹配的函数

到第2步为止，`void f(int, int)`和`void f(double, double = 3.14)`都属于可行函数，第3步中，`void f(double, double = 3.14)`最匹配（因为与实参精确匹配）


## 函数指针

函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由返回类型和形参类型共同决定，与函数名无关。

    bool lengthCompare(const string&, const string&);

函数的类型为`bool (const string&, const string&);`，指向该函数的指针，使用指针替换函数名即可

    bool (*pf)(const string&, const string&);

`*pf`两端的括号不可少，否则就变成了返回值是`bool`指针的函数。


### 使用函数指针

    //将函数名作为一个值使用时，该函数自动转换成指针
    pf = lengthCompare;                 //pf指向名为lengthCompare的函数
    pf = &lengthCompare;                //等价的赋值语句，取址符可选

    //使用指针直接调用函数
    bool b1 = pf("hello", "goodbye");
    bool b2 = (*pf)("hello", "goodbye");
    bool b3 = lengthCompare("hello", "goodbye");

在指向不同函数类型的指针间不存在转换规则。可以为函数指针付一个nullptr或者值为0的整型常量表达式，表示指针没有指向任何一个函数。

    string::size_type sumLength(const string&, const string&);
    bool cstringCompare(const char*, const char*);
    pf = 0;                             //正确：pf不指向任何函数
    pf = sumLength;                     //错误：返回类型不匹配
    pf = cstringCompare;                //错误，形参类型不匹配
    pf = lengthCompare;                 //正确，精确匹配

### 重载函数的指针

使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。

### 函数指针形参

和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用：

    //第3个形参是函数类型，它会自动转换成指向函数的指针
    void useBigger(const string &s1, const string &s2,
                    bool pf(const string&, const string&));
    //等价的声明，显式将形参定义成指向函数的指针
    void useBigger(const string &s1, const string &s2,
                    bool (*pf)(const string&, const string&));

可以直接把函数作为实参使用，它会自动转换成指针：

    //自动将函数转换成指向该函数的指针
    useBigger(s1, s2, lengthCompare);

使用`typedef`和`decltype`可以简化使用了函数指针的代码

    //Func和Func2是函数类型
    typedef bool Func(const string&, const string&);
    typedef decltype(lengthCompare) Func2;
    //FuncP和FuncP2是指向函数的指针
    typedef bool (*FuncP)(const string&, const string&);
    typedef decltype(lengthCompare) *FuncP2;

    //useBigger的等价声明，其中使用了类型别名
    void useBigger(const string&, const string&, Func);
    void useBigger(const string&, const string&, FuncP2);

这两个声明语句声明的是同一个函数，在第一条语句中，编译器自动将`Func`表示的函数类型转换成指针

### 返回指向函数的指针

和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。

使用类型别名

    using F = int (int*, int);          //F是函数类型，不是指针
    using PF = int (*)(int*, int);      //PF是指针类型

    PF f1(int);                         //正确:PF是指向函数的指针，f1返回指向函数的指针
    F f1(int);                          //错误:F是函数类型，f1不能返回一个函数
    F *f1(int);                         //正确：显式地指定返回类型是指向函数的指针

也可以用下面的形式直接声明f1

    int (*f1(int))(int*, int);

按照从内向外的顺序读，`f1`有形参列表，`f1`是一个函数；`f1`前面有*，所以`f1`返回一个指针；指针类型本身有包含形参列表，因此指针指向函数，该函数的返回类型是`int`

### 将auto和decltype用于函数指针类型

如果明确的知道返回的函数是哪一个，就能使用`decltype`简化书写函数指针返回类型的过程。

    string::size_type sumLength(const string&, const string&);
    string::size_type largeLength(const string&, const string&);
    //根据形参的取值，getFcn函数返回指向sumLength或者largeLength的指针
    decltype(sumLength) *getFcn(const string&);

当使用`decltype`作用于某个函数时，它返回函数类型而非指针类型。所以需要显式的加上*表示返回指针




 