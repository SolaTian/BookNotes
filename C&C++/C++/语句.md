# 语句

大部分与C语言一致

## switch的内部变量定义

如果需要为某个`case`分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有`case`标签都在变量的作用域之外。

## for语句

### 传统for语句

和C语言一致

    for(init-statement; condition; expression)
        statement;

其中，`for`语句头中的三个部分都能省略。

### 范围for语句

    for(declartion : expression)
        statement

`expression`表示的必须是一个序列，比如用花括号括起来的初始值列表、数组、或者`vector`或`string`等类型的对象，这些类型的共同特点是拥有能返回迭代器的`begin`和`end`成员。

`declartion`定义一个变量，序列中的每个元素都能转换成该变量的类型。确保类型相同的最简单办法是使用`auto`类型说明符。

    vector<int> v = {0,1,2,3,4,5,6,7,8,9};
    for(auto &r : v)
        r *= 2;
    
等价于

    for(auto beg = v.begin(), end = v.end(); beg != end; ++beg)
    {
        auto &r = *beg;                 //r必须是引用类型，这样才能对元素执行写操作
        r *= 2;
    }

## 跳转语句

`break`语句负责终止离它最近的`while`，`do while`，`for`或`switch`语句，并从这些语句之后开始继续执行。

`continue`语句终止最近的循环中的当前迭代并立即开始下一次迭代。

## try语句块和异常处理

### throw表达式

    Sales_item item1, item2;
    cin >> item1 >> item2;
    if(item1.isbn() == item2.isbn())
    {
        cout << item1 + item2 << endl;
        return 0;
    }
    else
    {
        cerr << "Data must refer to same ISBN" << endl;
        return -1;
    }

在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。改写程序不再输出一条信息，而是抛出异常

    if(item1.isbn() != item2.isbn())
    {
        throw runtime_error("Data must refer to same ISBN");
    }
    cout << item1 + item2 << endl;

### try语句块

    while(cin >> item1 >> item2)
    {
        try{
            if(item1.isbn() != item2.isbn())
            {
                throw runtime_error("Data must refer to same ISBN");
            }
            cout << item1 + item2 << endl;
        }
        catch (runtime_error)
        {
            cout << err.what()
                << "\nTry Again? Enter y or n"<< endl;
            char c;
            cin >> c;
            if(!cin || c == n)
            {
                break;      //跳出while循环
            }
        }
    }

`try`语句后可以接多个`catch`子句，具体看`try`语句块中可能抛出几个异常。