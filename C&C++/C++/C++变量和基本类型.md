# C++的变量和基本类型

## 内置类型

## 变量

### 变量和对象

|||
|-|-|
|||

变量的初始化，C++支持像C语言那样初始化，同样也支持列表初始化，如对`int`型变量的初始化

    int uins = 0;
    int uins = {0};
    int uins{0};            //列表初始化
    int uins(0);            

### 默认初始化

> 默认初始化：定义变量的时候没有指定初值，则变量被默认初始化，此时变量被赋予默认值，默认值是什么由变量类型决定，同时定义变量的位置也会对此有影响。

1. 内置类型未被初始化，定义在任何函数体之外的的变量被初始化为0
2. 内置类型未被初始化，定义在函数体内部的变量将不被初始化。一个未被初始化的内置类型的变量的值是未定义的，如果试图拷贝或者以其他形式访问此类值将引发错误。


每个类各自决定其初始化对象的方式，并且，是否允许不经初始化就定义对象也是由类决定。如果允许，它将决定对象的初始值是什么。绝大多数类支持无需显式初始化对象，这样的类提供了一个合适的默认值。如`string`类规定如果没有指定初值则生成一个空串。而有一些类要求每一个对象都显式初始化，如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。

### 变量声明和定义的关系

变量的声明规定了变量的类型和名字，在这一点上定义与之相同，但是定义还同时会申请存储空间，也可能会为变量赋一个初始值。

声明需要在变量名前添加关键字`extern`，而且不要显式地初始化变量。

    extern int i;      //声明i而非定义i
    int j;             //声明并定义j
    extern double pi = 3.1415;   //定义，显示初始化抵消了extern

### 名字的作用域

作用域中一旦声明了某个名字，则其嵌套的所有的作用域都能访问该名字，且允许在内层作用域重新定义外层作用域已有的名字。



## 复合类型

C++有几种复合类型：
- 数组
- 结构体
- 联合体
- 类
- 枚举
- 指针
- 引用
- 字符串
- 模板类

这里只介绍引用和指针。

### 引用

> 引用为对象起了另一个名字，引用类型引用另外一种类型。通过将声明符写成`&d`的形式来定义引用类型，`d`是声明的变量名。

    int ival = 1024;
    int &reval = ival;              //reval指向ival（是ival的另一个名字）
    int &reval2;                    //报错，引用必须被初始化

在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将一直和它的初始值对象绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。



**引用即别名：引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。**

    reval = 11;             //把2赋值给reval指向的对象，即赋给了ival
    int ii = reval;         //与ii = ival执行结果一样

为引用赋值，其实是把值赋值给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。

以引用作为初始值，实际上是以与引用绑定的对象作为初始值

    int &reval3 = reval;    //reval3绑定到那个与reval绑定的对象上，即绑定到了ival上
    int i = reval;          //i被初始化为ival的值，利用reval绑定的对象初始化变量i

允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号`&`开头

    int i1 = 1024, i2 = 2048;
    int &r = i; r2 = i2;
    int i3 = 1024, &ri = i3;    
    int &r3 = i3, &r4 =i2;

引用只能绑定在对象上，不能绑定在字面值或者某个表达式的计算结果，且引用的类型需要和与之绑定的对象严格匹配。

    int &reval4 = 10;        //错误

    double dval = 3.14;
    int reval5 = dval;       //错误


### 指针

> 指针：指针是指向另外一种类型的复合类型。与引用类似，指针实现了对其他对象的间接访问。

指针和引用相比的不同点：
- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内，它可以先后指向几个不同的对象.
- 指针无需在定义的时候赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。


引用本身不是一个对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用。

    int i = 42;
    int *p;             //p是一个int型指针
    int *&r = p;        //r是一个对指针p的引用

    r = &i;             //r引用了一个指针，因此给r赋值&i就是令p指向i
    *r = 0;             //解引用r得到i，也就是p指向的对象，将i值改为0


## const限定符

### const的引用

与普通的引用不同的是，对常量的引用不能被用作修改它所绑定的对象。

    const int ci = 1024;
    const int &r1 = ci;         //正确，引用及其对应的对象都是常量
    r1 = 42;                    //错误，r1是对常量的引用
    int &r2 = ci;               //错误，试图让一个非常量引用指向一个常量对象

对`const`的引用简称为常量引用。

    int i = 42;
    int &r1 = i;                //引用r1绑定对象
    const int &r2 = i;          //r2也绑定对象i，但是不允许通过r2修改i的值
    r1 = 0;                     //r1非常量，i的值修改为0
    r2 = 0;                     //错误，r2是一个常量引用

`r2`绑定非常量整数`i`是合法的行为。但是不允许通过`r2`修改`i`的值。但是可以通过其他的方式对`i`的值进行修改。


### 指针和const

指向常量的指针，不能用于改变其所指对象的值。想要存放常量对象的地址，只能使用指向常量的指针。

    const double pi = 3.14;         //pi是个常量，它的值不能变
    double *ptr = &pi;              //错误，ptr是个普通指针
    const double *cptr = &pi;       //正确，cptr可以指向一个双精度常量
    *cptr = 42;                     //错误，不能给*cptr赋值

和引用一样，指向常量的指针没有要求其所指向的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针来修改对象的值，没有规定那个对象的值不能通过其他的方式进行改变。

    double dval = 3.14;             //dval是一个双精度浮点值，它的值可以改变
    cptr = &dval;                   //正确，但是不能通过cptr来修改dval的值

指针是对象而引用不是，可以把指针本身定义为常量。常量指针必须初始化。一旦初始化完成之后，它的值就不能再改变了。把`*`放在`const`之前就说明指针是一个常量。即不变的的是指针本身而非指向的那个值。

    int errNum = 0;
    int *const curErr = &errNumb;           //curErr将一直指向errNumb
    const double pi = 3.1415;               
    const double *const pip = &pi;          //pip是一个指向常量对象的常量指针

弄清楚这些声明的含义，要从右往左阅读。`curErr`最近的符号是`const`，意味着`curErr`本身是一个常量对象，对象的类型由声明的其余部分确定。声明的下一个符号是`*`，则说明是一个指针常量。


### 顶层const 

用顶层`const`表示指针本身就是个常量，而用底层`const`表示指针所指的对象是一个常量。顶层`const`表示任意数据类型的对象是常量，而底层`const`则与指针和引用等复合类型的基本类型部分有关。指针类型即可以是顶层`const`，也可以是底层`const`。

    int i = 0;
    int *const p1 = &i;         //不能改变p1的值，是一个顶层const
    const int ci = 42;          //不能改变ci的值，是一个顶层const
    const int *p2 = &ci;        //允许改变p2的值，是一个底层const
    const int *const p3 = p2;   //靠右的是顶层const，靠左的是底层const 
    const int &r = ci;          //用于声明引用的const都是底层const 

当执行拷贝操作的时候，顶层`const`不受什么影响

    i = ci;                     //正确，拷贝ci的值，ci是一个顶层const
    p2 = p3;                    //正确，p2和p3指向的对象类型相同，p3的顶层const部分不起作用

当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层`const`资格，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转换成常量。

    int *p = p3;                //错误，p3包含底层const的定义，而p没有
    p2 = p3;                    //正确，p2和p3都是底层const
    p2 = &i;                    //正确，int *能转换成const int *
    int &r = ci;                //错误，普通的int&不能绑定到int常量上
    const int &r2 = i;          //正确，const int&能够绑定到一个普通的int上


### constexpr和常量表达式

常量表达式是指值不会改变且在编译过程中就能得到计算结果的表达式。

`constexpr`类型，由编译器来验证变量的值是否为一个常量表达式。声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化

    constexpr int mf = 20;              //20是常量表达式
    constexpr int limit = mf+1;         //mf+1是常量表达式
    constexpr int sz = size();          //只有当size是一个constexpr函数时，才是一条正确的语句

字面值类型

常量表达式的值需要在编译的时候就得到计算，因此对于声明`constexpr`时用到的类型有所限制。因为这些类型比较简单，就把它们称为字面值类型。


算数类型、引用和指针都属于字面值类型。IO库，string类型则不属于字面值类型，也不能被定义成为`constexpr`。

如果使用了`constexpr`声明中如果定义了一个指针，限定符`constexpr`仅对指针有效，与指针所指的对象无关。

    const int *p = nullptr;             //p是一个指向整型常量的指针，指向常量的指针
    constexpr int *q = nullptr;         //q是一个指向整数的常量指针，常量指针

`constexpr`把它所定义的对象置为了顶层`const`。

    int j = 0;
    constexpr int i = 42;               //i的类型是整型常量
    constexpr const int *p = &i;        //p是常量指针，指向整型常量i
    constexpr int *p1 = &j;             //p1是常量指针，指向整数j

## 处理类型

### 类型别名

类型别名是某种类型的同义词。有两种方法

1. 使用C语言中的`typedef`关键字
        
        typedef double wages;       //wages是double的同义词
        typedef wages base, *p;     //base是double的同义词，p是double*的同义词

2. 别名声明，`using`

        using SI = Sales_items;     //SI是Sales_item的同义词

### auto类型说明符

使用`auto`让编译器通过初始值来推算变量的类型。`auto`定义的变量必须要有初始值。

    auto item = val1 + val2;        //item初始化为val1和val2相加的结果

编译器推断出来的`auto`类型有时候和初始值的类型并不完全一样，编译器会适当修改结果类型使其更加符合初始化规则。

    //编译器以引用对象的类型作为auto的类型
    int i = 0, &r = i;
    auto a = r;                     //a是一个整数，(r是i的别名，而i是一个整数)

    //auto会忽略掉顶层const，同时底层const则会保留下来
    const int ci = i, &cr = ci;
    auto b = ci;                    //b是一个整数（ci的顶层const特性被忽略）
    auto c = cr;                    //c是一个整数（cr是ci的别名，ci本身是一个顶层const）
    auto d = &i;                    //d是一个整型指针（整数的地址就是指向整数的指针）
    auto e = &ci;                   //e是一个指向整数常量的指针（对常量对象取地址是一种底层const）

    //需要明确指出顶层const
    const auto f = ci;              //ci的推演类型是int，f是const int

    //将引用的类型设为auto，此时原来的初始化仍然使用
    auto &g = ci;                   //g是一个整型常量引用，绑定到ci
    auto &h = 42;                   //错误：不能为非常量引用绑定字面值
    const auto &j = 42;             //正确，可以为常量引用绑定字面值

### decltype类型指示符

希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。

    decltype(f()) sum = x;          //sum的类型就是f的返回类型

编译器并不调用`f`，而是使用当调用发生时`f`的返回值类型作为`sum`的类型。

    const int ci = 0; &cj = ci;
    decltype(ci) x = 0;             //x的类型是const int
    decltype(cj) y = x;             //y的类型是const int&, y绑定到变量x
    decltype(cj) z;                 //错误：z是一个引用，必须初始化

    //如果decltype的类型不是一个变量，则decltype返回表达式结果对应的类型
    //decltype的结果可以是引用类型
    int i = 42, *p = &i, &r = i;
    decltype(r+0) b;                //正确：加法的结果是int，因此b是一个未初始化的int
    decltype(*p) c;                 //错误：c是int&，必须初始化


## 预处理器

C++会用到的一项预处理功能是头文件保护符，头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。`#define`把一个名字设置为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：`#ifdef`当且仅当变量已经定义时为真，`#ifndef`当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到`#endif`指令为止。


    //使用这些功能有效防止重复包含的发生
    #ifndef SASES_DATA_H
    #define SASES_DATA_H
    #include <string>

    struct Sales_data{
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
    }
    #endif 

如果再次包含`Sales_datas.h`，则`#ifndef`的检查结果为假，编译器将会忽略`#ifndef`到`#endif`之间的部分。

预处理器变量无视C++语言中关于作用域的规则。
